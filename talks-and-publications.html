<!Doctype html>
<html lang="en">
  <head>
    <base href="https://denotational.co.uk/">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>Ohad's Research - Home</title>

    <meta content="Ohad Kammar's Research" name="description" />
    <meta content="ohad kammar, ohad, kammar, research, publications,
    publication, programming language semantics, PLT semantics,
    semantics, category, categories, category theory, logic,
    computational effects, effect type systems, type and effect
    systems, types, effects, effect type system, access control, DCC,
    CDD, Plotkin, Gordon Plotkin, call by push value, CBPV,
    call-by-push-value, denotational semantics, continuations,
    delimited continuations, jump with argument" name="keywords" />
    <!-- EdGEL -->
    <link href="css/edgel-blue-university.css" rel="stylesheet">
    <link href="https://denotational.co.uk/favicon.ico"
          rel="icon" type="image/x-icon" />
    <link href="https://denotational.co.uk/favicon.ico"
          rel="shortcut icon" type="image/x-icon" />
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="js/html5shiv.min.js"></script>
            <script src="js/respond.min.js"></script>
            <![endif]-->
        <script src="js/picturefill.js"></script>
  </head>

  <body class="html not-front not-logged-in one-sidebar sidebar-first
               page-node page-node- page-node-4 node-type-homepage og-context
               og-context-node og-context-node-4 mlid-1258" itemscope=""
        itemtype="https://schema.org/WebPage" style=""
        cz-shortcut-listen="true"><div id="MathJax_Message" style="display:
                                                                   none;"></div>
    <div id="skip-link">
      <a href="#main-content" class="sr-only sr-only-focusable">Skip to main content</a>
    </div>



    <div class="page-head">
      <div class="container">
        <div class="row">
          <div class="col-sm-7 col-md-8">
            <a href="https://www.inf.ed.ac.uk/">
              <img class="uoe-logo"
                   src="https://denotational.co.uk/InformaticsUni_RGB.jpg"
                   alt="The
                        University of Edinburgh School of Informatic
                        home" /></a>
          </div>
          <div class="col-sm-5 col-md-4">
            <div class="page-head-text">
              <ul class="list-inline text-right">
                <li><a href="https://www.ed.ac.uk/schools-departments/">Schools &amp; departments</a></li>
                <li><a href="https://www.myed.ed.ac.uk/">MyEd</a></li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>



    <div class="page-head-hero">
      <div class="container">
        <div class="page-head-title">
          <h1>
            <a href="https://denotational.co.uk"
               class="active">Ohad Kammar</a>
          </h1>
          <h2 aria-hidden="true">
            <a href="https://royalsociety.org/grants-schemes-awards/grants/university-research/">
                University Research Fellow <br>
                Reader in Programming Languages
            </a>
          </h2>
        </div>
      </div>
    </div>


    <div class="container container-page-content">
      <div class="row">
        <div class="col-sm-3 col-uoe-nav">
          <div class="region region-sidebar-first">
            <section id="block-uoe-menu-uoe-menu-block"
                     class="block block-uoe-menu clearfix">
              <h2 class="uoe-nav-trigger">Menu</h2>
              <ul class="uoe-nav">
                <li class="uoe-nav-expanded uoe-published">
                  <a href="index.html#contact"
                     style="padding-bottom:0px">Contact</a>
                </li>
                <li>
                  <a style="padding:0px 15px; padding-bottom:0px"
                     href="index.html#interests">
                    Research interests</a>
                </li>
                <li class="uoe-nav" style="padding:0px 0px">
                  <block style="padding: 0px 15px; color:#555; font-weight:600">
                    Projects
                  </block>
                  <ul>
                    <li>
                      <a style="border-bottom:none; padding: 0px 30px"
                         href="index.html#current_projects">Current</a>
                    </li>
                    <li>
                      <a style="border-bottom:none; padding: 0px 30px"
                         href="index.html#future_projects">Future</a>
                    </li>
                    <li>
                      <a style="padding: 0px 30px"
                         href="index.html#past_projects">Past</a>
                    </li>
                  </ul>
                </li>
                <li class="uoe-nav">
                  <a style="border-bottom:none; padding: 0 15px"
                     href="index.html#pubs">Publications and preprints</a>
                  <ul>
                    <li class="uoe-nav">
                        <a style="padding:0px 30px"
                           href="talks-and-publications.html#publications">abstracts</a>
                    </li>
                  </ul>
                </li>
                <li class="uoe-nav">
                    <a href="index.html#teaching"
                       style="border-bottom:none; padding: 0 15px">
                        Teaching
                    </a>
                    <ul>
                        <li class="uoe-nav">
                            <a style="padding:0px 30px"
                               href="tdpm-anu-lss-2023">Type-Driven Modelling Course</a>
                        </li>
                    </ul>
                    <ul>
                        <li class="uoe-nav">
                            <a style="padding:0px 30px"
                               href="teaching/partII.html">UG/MInf projects</a>
                        </li>
                    </ul>
                    <ul>
                        <li class="uoe-nav">
                            <a style="padding:0px 30px"
                               href="teaching/partIII.html">MSc projects</a>
                        </li>
                    </ul>
                    <ul>
                        <li class="uoe-nav">
                            <a style="padding:0px 30px"
                               href="teaching">Courses</a>
                        </li>
                    </ul>
                </li>
                <li class="uoe-nav">
                  <a href="index.html#talks"
                     style="border-bottom:none; padding: 0 15px">
                    Talks
                  </a>
                  <ul>
                    <li class="uoe-nav">
                      <a style="padding:0px 30px"
                         href="talks-and-publications.html#talks">abstracts</a>
                    </li>
                  </ul>
                </li>
                <li class="uoe-nav">
                  <a href="index.html#reports"
                     style="border-bottom:none; padding: 0 15px">
                    Reports
                  </a>
                  <ul>
                    <li class="uoe-nav">
                      <a style="padding:0px 30px"
                         href="talks-and-publications.html#reports">abstracts</a>
                    </li>
                  </ul>
                </li>
                <li class="uoe-nav">
                  <a href="index.html#gigs"
                     style="padding:0pt 15px">
                    Upcoming gigs
                  </a>
                </li>
                <li class="uoe-nav">
                  <a style="padding:0px 15px"
                     href="index.html#services">
                    Community service
                  </a>
                <li class="uoe-nav">
                  <a style="padding:0px 15px"
                     href="index.html#media">
                    Media presence
                  </a>
                </li>
                <li class="uoe-nav">
                  <a style="padding:0px 15px"
                     href="index.html#consultancy">
                    Consultancy
                  </a>
                </li>
              </ul>
            </section>
          </div>
        </div>

        <div class="col-sm-9">
          <div class="row breadtrail">
            <div class="col-sm-9 col-md-10" itemprop="breadcrumb">
              <ol class="breadcrumb active">
                <li><a href="https://denotational.co.uk">Home</a></li>
              </ol>
            </div>
            <div class="col-sm-3 col-md-2">
          <a href="index.html#contact"
             class="btn btn-uoe btn-block contact-link"
             title="Ohad Kammar contact details">Contact me</a>
            </div>
          </div>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<head>
<META NAME="description" CONTENT="Ohad Kammar's Research">
<META NAME="keywords" CONTENT="ohad kammar, ohad, kammar, research, publications, publication, programming language
semantics, PLT semantics, semantics, category, categories, category theory, logic, computational
effects, effect type systems, type and effect systems, types, effects, effect type system, access control, DCC, CDD, Plotkin, Gordon Plotkin, call by push value, CBPV, call-by-push-value, denotational semantics, continuations, delimited continuations, jump with argument">
<TITLE>Ohad's Research - Talks and Publications</TITLE>
<link rel="icon" href="favicon.ico" type="image/x-icon" >
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" >
</HEAD>

<h3>
<a name="publications"></a>Publications
</h3>
<ul>
<li><h4>
<a
href="publications/simner-et-al-precise-exceptions-in-relaxed-architectures.pdf">Precise
exceptions in relaxed architectures</a>
</h4>
Ben Simner, Alasdair Armstrong, Thomas Bauereiss, Brian Campbell, Ohad
Kammar, Jean Pichon-Pharabod, and Peter Sewell. <BR><BR> Appears in the
<a href="https://dl.acm.org/doi/10.1145/3695053.3731102">52nd Annual
International Symposium on Computer Architecture</a>, 2025, <a
href="https://arxiv.org/abs/2412.15140">arXiv:2412.15140</a>, <a
href="https://doi.org/10.1145/3695053.3731102">DOI:
10.1145/3695053.3731102</a>. <BR>joint winner of the <a
href="https://iscaconf.org/isca2025/"><strong>2025 ISCA Best Paper
Award</strong></a>.</li>
</ul>
<blockquote>
<p>“To manage exceptions, software relies on a key architectural
guarantee—precision: that exceptions appear to execute between
instructions. However, this definition, dating back over 60 years,
fundamentally assumes a sequential programmers model. Modern
architectures such as Arm-A with programmer-observable relaxed behaviour
make such a naive definition inadequate, and it is unclear exactly what
guarantees programmers have on exception entry and exit. In this paper,
we clarify the concepts needed to discuss exceptions in the
relaxed-memory setting—a key aspect of precisely specifying the
architectural interface between hardware and software. We explore the
basic relaxed behaviour across exception boundaries, and the semantics
of external aborts, using Arm-A as a representative modern architecture.
We identify an important problem, present yet unexplored for decades:
pinning down what it means for exceptions to be precise in a relaxed
setting. We describe key phenomena that any definition should account
for. We develop an axiomatic model for Arm-A precise exceptions, tooling
for axiomatic model execution, and a library of tests. Finally we
explore the relaxed semantics of software-generated interrupts, as used
in sophisticated programming patterns, and sketch how they too could be
modelled.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/dvir-kammar-lahav-brookes-release-acquire-journal.pdf">A
Denotational Approach to Release/Acquire Concurrency</a>
</h4>
Yotam Dvir, Ohad Kammar, and Ori Lahav. <BR><BR> Appears in the <a
href="https://dl.acm.org/doi/10.1145/3715096">ACM Transaction on
Programming Languages and Systems</a>, 2025, <a
href="https://doi.org/10.1145/3715096">DOI: 10.1145/3715096</a>.</li>
</ul>
<blockquote>
<p>“We present a compositional denotational semantics for a functional
language with first-class parallel composition and shared-memory
operations whose operational semantics follows the Release/Acquire weak
memory model (RA). The semantics is formulated in Moggi’s monadic
approach, and is based on Brookes-style traces. To do so we adapt
Brookes’s traces to Kang et al.’s view-based machine for RA, and
supplement Brookes’s mumble and stutter closure operations with
additional operations, specific to RA. The latter provides a more
nuanced understanding of traces that uncouples them from operational
interrupted executions. We show that our denotational semantics is
adequate and use it to validate various program transformations of
interest. This is the first work to put weak memory models on the same
footing as many other programming effects in Moggi’s standard monadic
approach.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/eremondi-kammar-coverage-semantics-for-dependent-pattern-matching.pdf">Coverage
semantics for dependent pattern matching</a>
</h4>
Joseph Eremondi and Ohad Kammar. <BR><BR> Appears in the <a
href="https://link.springer.com/chapter/10.1007/978-3-031-91118-7_11">34th
European Symposium on Programming</a>, 2025, <a
href="https://arxiv.org/abs/2501.18087">arXiv:2501.18087</a>, <a
href="https://doi.org/10.1007/978-3-031-91118-7_11">DOI:
10.1007/978-3-031-91118-7_11</a>.</li>
</ul>
<blockquote>
<p>“Dependent pattern matching is a key feature in dependently typed
programming. However, there is a theory-practice disconnect: while many
proof assistants implement pattern matching as primitive, theoretical
presentations give semantics to pattern matching by elaborating to
eliminators. Though theoretically convenient, eliminators can be awkward
and verbose, particularly for complex combinations of patterns. This
work aims to bridge the theory-practice gap by presenting a direct
categorical semantics for pattern matching, which does not elaborate to
eliminators. This is achieved using sheaf theory to describe when sets
of arrows (terms) can be amalgamated into a single arrow. We present a
language with top-level dependent pattern matching, without specifying
which sets of patterns are considered covering for a match. Then, we
give a sufficient criterion for which pattern-sets admit a sound model:
patterns should be in the canonical coverage for the category of
contexts. Finally, we use sheaf-theoretic saturation conditions to
devise some allowable sets of patterns. We are able to express and
exceed the status quo, giving semantics for datatype constructors,
nested patterns, absurd patterns, propositional equality, and dot
patterns.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="drafts/dvir-kammar-lahav-plotkin-two-sorted-brookes.pdf">Two-sorted
algebraic decompositions of Brookes’s shared-state denotational
semantics</a>
</h4>
Yotam Dvir, Ohad Kammar, Ori Lahav, and Gordon Plotkin. <BR><BR> Appears
in the <a
href="https://link.springer.com/chapter/10.1007/978-3-031-90897-2_18">28th
International Conference on Foundations of Software Science and
Computation Structures</a>, 2025, <a
href="https://arxiv.org/abs/2501.15104">arXiv:2501.15104</a>, <a
href="https://doi.org/10.1007/978-3-031-90897-2_18">DOI:
10.1007/978-3-031-90897-2_18</a>.</li>
</ul>
<blockquote>
<p>“We use a two sorted equational theory of algebraic effects to model
concurrent shared state with preemptive interleaving, recovering
Brookes’s seminal 1996 trace-based model precisely. The decomposition
allows us to analyse Brookes’s model algebraically in terms of separate
but interacting components. The multiple sorts partition terms into
layers. We use two sorts: a ‘hold’ sort for layers that disallow
interleaving of environment memory accesses, analogous to holding a
global lock on the memory; and a ‘cede’ sort for the opposite. The
algebraic signature comprises of independent interlocking components:
two new operators that switch between these sorts, delimiting the atomic
layers, thought of as acquiring and releasing the global lock;
non-deterministic choice; and state-accessing operators. The axioms
similarly divide cleanly: the delimiters behave as a closure pair; all
operators are strict, and distribute over non-empty non-deterministic
choice; and non-deterministic global state obeys Plotkin and Power’s
presentation of global state. Our representation theorem expresses the
free algebras over a two-sorted family of variables as sets of traces
with suitable closure conditions. When the held sort has no variables,
we recover Brookes’s trace semantics.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/dvir-kammar-lahav-brookes-release-acquire-conference.pdf">A
Denotational Approach to Release/Acquire Concurrency</a>
</h4>
Yotam Dvir, Ohad Kammar, and Ori Lahav. <BR><BR> Appears in the <a
href="https://link.springer.com/chapter/10.1007/978-3-031-57267-8_5">European
Symposium on Programming</a>, 2024, <a
href="https://doi.org/10.1007/978-3-031-57267-8_5">DOI:
10.1007/978-3-031-57267-8_5</a>.</li>
</ul>
<blockquote>
<p>“We present a compositional denotational semantics for a functional
language with first-class parallel composition and shared-memory
operations whose operational semantics follows the Release/Acquire weak
memory model (RA). The semantics is formulated in Moggi’s monadic
approach, and is based on Brookes-style traces. To do so we adapt
Brookes’s traces to Kang et al.’s view-based machine for RA, and
supplement Brookes’s mumble and stutter closure operations with
additional operations, specific to RA. The latter provides a more
nuanced understanding of traces that uncouples them from operational
interrupted executions. We show that our denotational semantics is
adequate and use it to validate various program transformations of
interest. This is the first work to put weak memory models on the same
footing as many other programming effects in Moggi’s standard monadic
approach.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="https://michel.steuwer.info/files/publications/2024/POPL-2024-1.pdf">Shoggoth:
A Formal Foundation for Strategic Rewriting</a> (<a
href="https://www.youtube.com/watch?v=HRFiCObmVeQ&amp;list=PLyrlk8Xaylp4ZCixLbPzpALO4JEquzcvz&amp;index=29">video</a>)
</h4>
Xueying Qin, Liam O’Connor, Rob van Glabbeek, Peter Hoefner, Ohad
Kammar, and Michel Steuwer. <BR><BR> Appears in the <a
href="https://popl24.sigplan.org/details/POPL-2024-popl-research-papers/5/Shoggoth-A-Formal-Foundation-for-Strategic-Rewriting">51st
ACM SIGPLAN Symposium on Principles of Programming Languages</a>, 2024,
<a href="https://doi.org/10.1145/3633211">DOI: 10.1145/3633211</a>.</li>
</ul>
<blockquote>
<p>“Rewriting is a versatile and powerful technique used in many
domains. Strategic rewriting allows programmers to control the
application of rewrite rules by composing individual rewrite rules into
complex rewrite strategies. These strategies are semantically complex,
as they may be nondeterministic, they may raise errors that trigger
backtracking, and they may not terminate. Given such semantic
complexity, it is necessary to establish a formal understanding of
rewrite strategies and to enable reasoning about them in order to answer
questions like: How do we know that a rewrite strategy terminates? How
do we know that a rewrite strategy does not fail because we compose two
incompatible rewrites? How do we know that a desired property holds
after applying a rewrite strategy? In this paper, we introduce Shoggoth:
a formal foundation for understanding, analysing and reasoning about
strategic rewriting that is capable of answering these questions. We
provide a denotational semantics of System S, a core language for
strategic rewriting, and prove its equivalence to our big-step
operational semantics, which extends existing work by explicitly
accounting for divergence. We further define a location-based weakest
precondition calculus to enable formal reasoning about rewriting
strategies, and we prove this calculus sound with respect to the
denotational semantics. We show how this calculus can be used in
practice to reason about properties of rewriting strategies, including
termination, that they are well-composed, and that desired
postconditions hold. The semantics and calculus are formalised in
Isabelle/HOL and all proofs have been mechanised.”</p>
</blockquote>
<ul>
<li><h4>
<a href="publications/dvir-kammar-lahav-algebraic-sc.pdf">An Algebraic
Theory for Shared-State Concurrency</a>
</h4>
Yotam Dvir, Ohad Kammar, and Ori Lahav. <BR><BR> Appears in the <a
href="https://link.springer.com/chapter/10.1007/978-3-031-21037-2_1">Asian
Symposium on Programming Languages and Systems 2022</a>, 2022, <a
href="https://doi.org/10.1007/978-3-031-21037-2_1">DOI:
10.1007/978-3-031-21037-2_1</a>.</li>
</ul>
<blockquote>
<p>“We present a monadic denotational semantics for a higher-order
programming language with shared-state concurrency, i.e. global-state in
the presence of interleaving concurrency. Central to our approach is the
use of Plotkin and Power’s algebraic effect methodology: designing an
equational theory that captures the intended semantics, and proving a
monadic representation theorem for it. We use Hyland et al.’s equational
theory of resumptions that extends non-deterministic global-state with
an operator for yielding to the environment. The representation is based
on Brookes-style traces. Based on this representation we define a
denotational semantics that is directionally adequate with respect to a
standard operational semantics. We use this semantics to justify
compiler transformations of interest: redundant access eliminations,
each following from a mundane algebraic calculation; while structural
transformations follow from reasoning over the monad’s interface.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/kammar-katsumata-saville-fully-abstract-models-for-effectful-lambda-calculi.pdf">Fully
abstract models for effectful lambda-calculi via category-theoretic
logical relations</a> (<a href="https://youtu.be/qJmNWvf6jlU">video</a>,
<a
href="https://dl.acm.org/action/downloadSupplement?doi=10.1145/3498705&amp;file=popl22main-p331-p-video.mp4">short
video</a>)
</h4>
Ohad Kammar, Shin-ya Katsumata, and Philip Saville. <BR><BR> Appears in
the <a
href="https://popl22.sigplan.org/details/POPL-2022-popl-research-papers/44/Fully-Abstract-Models-for-Effectful-Calculi-via-Category-Theoretic-Logical-Relation">49th
ACM SIGPLAN Symposium on Principles of Programming Languages</a>, 2022,
<a href="https://doi.org/10.1145/3498705">DOI: 10.1145/3498705</a>.</li>
</ul>
<blockquote>
<p>“We present a construction which, under suitable assumptions, takes a
model of Moggi’s computational lambda-calculus with sum types, effect
operations and primitives, and yields a model that is adequate and fully
abstract. The construction, which uses the theory of fibrations,
categorical glueing, top-top-lifting, and top-top-closure, takes
inspiration from O’Hearn &amp; Riecke’s fully abstract model for PCF.
Our construction can be applied in the category of sets and functions,
as well as the category of diffeological spaces and smooth maps and the
category of quasi-Borel spaces, which have been studied as semantics for
differentiable and probabilistic programming.”</p>
</blockquote>
<ul>
<li><h4>
<a href="publications/vidgen-et-al-nlpcss2020.pdf">Recalibrating
classifiers for interpretable abusive content detection</a>
</h4>
Bertie Vidgen, Sam Staton, Scott A. Hale, Ohad Kammar, Helen Margetts,
Tom Melham, Marcin Szymczak. <BR><BR> Appears in the <a
href="https://aclanthology.org/2020.nlpcss-1.14/">Fourth Workshop on
Natural Language Processing and Computational Social Science</a>, 2020,
<a href="https://doi.org/10.18653/v1/2020.nlpcss-1.14">DOI:
10.18653/v1/2020.nlpcss-1.14</a>.</li>
</ul>
<blockquote>
<p>“We investigate the use of machine learning classifiers for detecting
online abuse in empirical research. We show that uncalibrated clas-
sifiers (i.e. where the ‘raw’ scores are used) align poorly with human
evaluations. This limits their use for understanding the dynamics,
patterns and prevalence of online abuse. We examine two widely used
classifiers (created by Perspective and Davidson et al.) on a dataset of
tweets directed against candidates in the UK’s 2017 general election. A
Bayesian approach is presented to recalibrate the raw scores from the
classifiers, using probabilistic programming and newly annotated data.
We argue that interpretability evaluation and recal- ibration is
integral to the application of abusive content classifiers.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/forster-kammar-lindley-pretnar-on-the-expressive-power-of-user-defined-effects-journal.pdf">On
the expressive power of user-defined effects: effect handlers, monadic
reflection, delimited control (updated version)</a> (<a
href="https://podcasts.ox.ac.uk/expressive-power-user-defined-effects-effect-handlers-monadic-reflection-delimited-control">video</a>)
</h4>
Yannick Forster, Ohad Kammar, Sam Lindley, and Matija Pretnar. <BR><BR>
Appears in the <a
href="http://icfp17.sigplan.org/track/icfp-2017-papers#event-overview">Journal
of functional programming</a>, 2019, <a
href="https://arxiv.org/abs/1610.09161">arXiv:1610.09161</a>, <a
href="https://doi.org/10.1145/3110257">DOI: 10.1145/3110257</a>.
<BR>Expanded and updated version of the previous <a
href="https://icfp17.sigplan.org/details/icfp-2017-papers/6/On-the-Expressive-Power-of-User-Defined-Effects-Effect-Handlers-Monadic-Reflection-Delimited-Control">ICFP’17
paper</a>.</li>
</ul>
<blockquote>
<p>” We compare the expressive power of three programming abstractions
for user-defined computational effects: Plotkin and Pretnar’s effect
handlers, Filinski’s monadic reflection, and delimited control. This
comparison allows a precise discussion about the relative expressiveness
of each programming abstraction. It also demonstrates the sensitivity of
the relative expressiveness of user-defined effects to seemingly
orthogonal language features. <BR/><BR/> We present three calculi, one
per abstraction, extending Levy’s call-by-push-value. For each calculus,
we present syntax, operational semantics, a natural type-and-effect
system, and, for effect handlers and monadic reflection, a set-theoretic
denotational semantics. We establish their basic metatheoretic
properties: safety, termination, and, where applicable, soundness and
adequacy. Using Felleisen’s notion of a macro translation, we show that
these abstractions can macro-express each other, and show which
translations preserve typeability. We use the adequate finitary
set-theoretic denotational semantics for the monadic calculus to show
that effect handlers cannot be macro-expressed while preserving
typeability either by monadic reflection or by delimited control. Our
argument fails with simple changes to the type system such as
polymorphism and inductive types. We supplement our development with a
mechanised Abella formalisation.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/vakar-kammar-staton-a-domain-theory-for-statistical-probabilistic-programming.pdf">A
Domain Theory for Statistical Probabilistic Programming</a> (<a
href="https://dl.acm.org/ft_gateway.cfm?id=3290349&amp;ftid=2038039&amp;dwn=1">video</a>)
</h4>
Matthijs Vákár, Ohad Kammar, and Sam Staton. <BR><BR> Appears in the <a
href="https://popl19.sigplan.org/event/popl-2019-research-papers-a-domain-theory-for-statistical-probabilistic-programming">46th
ACM SIGPLAN Symposium on Principles of Programming Languages</a>, 2019,
<a href="https://doi.org/10.1145/3290349">DOI: 10.1145/3290349</a>.
<BR>Selected by the programme committee for the <strong><a
href="https://popl19.sigplan.org/event/popl-2019-research-papers-a-domain-theory-for-statistical-probabilistic-programming">Distinguished
Paper Award</a></strong>. Awarded to at most 10% of accepted papers, to
highlight them as papers that should be read by a broad audience due to
their relevance, originality, significance, and clarity.</li>
</ul>
<blockquote>
<p>” We give an adequate denotational semantics for languages with
recursive higher-order types, continuous probability distributions, and
soft constraints. These are expressive languages for building Bayesian
models of the kinds used in computational statistics and machine
learning. Among them are untyped languages, similar to Church and
WebPPL, because our semantics allows recursive mixed-variance datatypes.
Our semantics justifies important program equivalences including
commutativity. <BR/><BR/> Our new semantic model is based on
`quasi-Borel predomains’. These are a mixture of chain-complete partial
orders (cpos) and quasi-Borel spaces. Quasi-Borel spaces are a recent
model of probability theory that focuses on sets of admissible random
elements. Probability is traditionally treated in cpo models using
probabilistic powerdomains, but these are not known to be commutative on
any class of cpos with higher order functions. By contrast, quasi-Borel
predomains do support both a commutative probabilistic powerdomain and
higher-order functions. As we show, quasi-Borel predomains form both a
model of Fiore’s axiomatic domain theory and a model of Kock’s synthetic
measure theory. ”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/yallop-von-glehn-kammar-partially-static-data-as-free-extension-of-algebras.pdf">Partially
static data as free extension of algebras</a>
</h4>
Jeremy Yallop, Tamara von Glehn, Ohad Kammar. <BR><BR> Appears in the <a
href="https://icfp18.sigplan.org/event/icfp-2018-papers-partially-static-data-as-free-extension-of-algebras">International
Conference on Functional Programming 2018</a>, 2018, <a
href="https://doi.org/10.1145/3236795">DOI: 10.1145/3236795</a>.</li>
</ul>
<blockquote>
<p>“Partially-static data structures are a well-known technique for
improving binding times. However, they are often defined in an ad-hoc
manner, without a unifying framework to ensure full use of the equations
associated with each operation. We present a foundational view of
partially-static data structures as free extensions of algebras for
suitable equational theories, i.e. the coproduct of an algebra and a
free algebra in the category of algebras and their homomorphisms. By
precalculating these free extensions, we construct a high-level library
of partially static data representations for common algebraic
structures. We demonstrate our library with common use-cases from the
literature: string and list manipulation, linear algebra, and numerical
simplification.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/scibior-kammar-ghahramani-funcitonal-programming-for-modular-bayesian-inference.pdf">Functional
programming for modular Bayesian inference</a>
</h4>
Adam Ścibior Ohad Kammar, and Zoubin Ghahramani. <BR><BR> Appears in the
<a
href="https://icfp18.sigplan.org/event/icfp-2018-papers-functional-programming-for-modular-bayesian-inference">International
Conference on Functional Programming 2018</a>, 2018, <a
href="https://doi.org/10.1145/3236778">DOI: 10.1145/3236778</a>.</li>
</ul>
<blockquote>
<p>“We present an architectural design of a library for Bayesian
modelling and inference in modern functional programming languages. The
novel aspect of our approach are modular correct-by-construction
implementations of existing state-of-the-art inference algorithms. Our
design relies on three inherently functional features: higher-order
functions, inductive data-types, and support for either type-classes or
an expressive module system. We provide a performant Haskell
implementation of this architecture, demonstrating that high-level and
modular probabilistic programming can be added as a library in
sufficiently expressive languages. We review the core abstractions in
this architecture: inference representations, inference transformations,
and inference representation transformers. We then implement concrete
instances of these abstractions, counterparts to particle filters and
Metropolis-Hastings samplers, which form the basic building blocks of
our library. By composing these building blocks we obtain
state-of-the-art inference algorithms: Resample-Move Sequential Monte
Carlo, Particle Marginal Metropolis-Hastings, and Sequential Monte Carlo
squared. We evaluate our implementation against existing probabilistic
programming systems and find it is already com- petitively performant,
although we conjecture that existing functional programming optimisation
techniques could reduce the overhead associated with the abstractions we
use. We show that our modular design enables deterministic testing of
inherently stochastic Monte Carlo algorithms. Finally, we demonstrate
using OCaml that an expressive module system can also implement our
design.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/mfps-kammar-mcdermott-factorisation-systems.pdf">Factorisation
systems for logical relations and monadic lifting in type-and-effect
system semantics</a>
</h4>
Ohad Kammar and Dylan McDermott. <BR><BR> Appears in the <a
href="https://www.mathstat.dal.ca/mfps2018/">34th Conference on the
Mathematical Foundations of Programming Semantics</a>, 2018, <a
href="https://arxiv.org/abs/1804.03460">arXiv:1804.03460</a>, <a
href="https://doi.org/10.1016/j.entcs.2018.11.012">DOI:
10.1016/j.entcs.2018.11.012</a>.</li>
</ul>
<blockquote>
<p>“Type-and-effect systems incorporate information about the
computational effects, e.g., state mutation, probabilistic choice, or
I/O, a program phrase may invoke alongside its return value. A semantics
for type-and-effect systems involves a parameterised family of monads
whose size is exponential in the number of effects. We derive such
refined semantics from a single monad over a category, a choice of
algebraic operations for this monad, and a suitable factorisation system
over this category. We relate the derived semantics to the original
semantics using fibrations for logical relations. Our proof uses a
folklore technique for lifting monads with operations.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/scibior-kammar-vakar-staton-yang-cai-ostermann-moss-heunen-ghahramani-denotational-validation-of-higher-order-bayesian-inference.pdf">Denotational
validation of Bayesian inference</a> (<a
href="https://dl.acm.org/ft_gateway.cfm?id=3158148&amp;ftid=1941546&amp;dwn=1">video</a>)
</h4>
Adam Ścibior, Ohad Kammar, Matthijs Vákár, Sam Staton, Hongseok Yang,
Yufei Cai, Klaus Ostermann, Sean K. Moss, Chris Heunen, and Zoubin
Ghahramani. <BR><BR> Appears in the <a
href="https://popl18.sigplan.org/event/popl-2018-papers-denotational-validation-of-higher-order-bayesian-inference">45th
ACM SIGPLAN Symposium on Principles of Programming Languages</a>, 2018,
<a href="https://arxiv.org/abs/1711.03219">arXiv:1711.03219</a>, <a
href="https://doi.org/10.1145/3158148">DOI: 10.1145/3158148</a>.</li>
</ul>
<blockquote>
<p>“We present a modular semantic account of Bayesian inference
algorithms for probabilistic programming languages, as used in data
science and machine learning. Sophisticated inference algorithms are
often explained in terms of composition of smaller parts. However,
neither their theoretical justification nor their implementation
reflects this modularity. We show how to conceptualise and analyse such
inference algorithms as manipulating intermediate representations of
probabilistic programs using higher-order functions and inductive types,
and their denotational semantics. <BR/><BR/> Semantic accounts of
continuous distributions use measurable spaces. However, our use of
higher-order functions presents a substantial technical difficulty: it
is impossible to define a measurable space structure over the collection
of measurable functions between arbitrary measurable spaces that is
compatible with standard operations on those functions, such as function
application. We overcome this difficulty using quasi-Borel spaces, a
recently proposed mathematical structure that supports both function
spaces and continuous distributions. <BR/><BR/> We define a class of
semantic structures for representing probabilistic programs, and
semantic validity criteria for transformations of these representations
in terms of distribution preservation. We develop a collection of
building blocks for composing representations. We use these building
blocks to validate common inference algorithms such as Sequential Monte
Carlo and Markov Chain Monte Carlo. To emphasize the connection between
the semantic manipulation and its traditional measure theoretic origins,
we use Kock’s synthetic measure theory. We demonstrate its usefulness by
proving a quasi-Borel counterpart to the Metropolis-Hastings-Green
theorem.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/forster-kammar-lindley-pretnar-on-the-expressive-power-of-user-defined-effects-conference.pdf">On
the expressive power of user-defined effects: effect handlers, monadic
reflection, delimited control</a> (<a
href="https://podcasts.ox.ac.uk/expressive-power-user-defined-effects-effect-handlers-monadic-reflection-delimited-control">video</a>)
</h4>
Yannick Forster, Ohad Kammar, Sam Lindley, and Matija Pretnar. <BR><BR>
Appears in the <a
href="http://icfp17.sigplan.org/track/icfp-2017-papers#event-overview">22nd
ACM SIGPLAN International Conference on Functional Programming</a>,
2017, <a href="https://arxiv.org/abs/1610.09161">arXiv:1610.09161</a>,
<a href="https://doi.org/10.1145/3110257">DOI: 10.1145/3110257</a>.</li>
</ul>
<blockquote>
<p>“We compare the expressive power of three programming abstractions
for user-defined computational effects: Bauer and Pretnar’s effect
handlers, Filinski’s monadic reflection, and delimited control without
answer-type-modification. This comparison allows a precise discussion
about the relative expressiveness of each programming abstraction. It
also demonstrates the sensitivity of the relative expressiveness of
user-defined effects to seemingly orthogonal language features.
<BR/><BR/> We present three calculi, one per abstraction, extending
Levy’s call-by-push-value. For each calculus, we present syntax,
operational semantics, a natural type-and-effect system, and, for effect
handlers and monadic reflection, a set-theoretic denotational semantics.
We establish their basic meta-theoretic properties: safety, termination,
and, where applicable, soundness and adequacy. Using Felleisen’s notion
of a macro translation, we show that these abstractions can
macro-express each other, and show which translations preserve
typeability. We use the adequate finitary set-theoretic denotational
semantics for the monadic calculus to show that effect handlers cannot
be macro-expressed while preserving typeability either by monadic
reflection or by delimited control. We supplement our development with a
mechanised Abella formalisation.”</p>
</blockquote>
<ul>
<li><h4>
<a href="drafts/heunen-kammar-staton-yang-staton-spaces.pdf">A
convenient category for higher-order probability theory</a>
</h4>
Chris Heunen, Ohad Kammar, Sam Staton, Hongseok Yang. <BR><BR> Appears
in the <a href="http://ieeexplore.ieee.org/document/8005137/">32st
Annual ACM/IEEE Symposium on Logic in Computer Science</a>, 2017, <a
href="https://arxiv.org/abs/1701.02547">arXiv:1701.02547</a>, <a
href="https://doi.org/10.1109/LICS.2017.8005137">DOI:
10.1109/LICS.2017.8005137</a>.</li>
</ul>
<blockquote>
<p>“Higher-order probabilistic programming languages allow programmers
to write sophisticated models in machine learning and statistics in a
succinct and structured way, but step outside the standard
measure-theoretic formalization of probability theory. Programs may use
both higher-order functions and continuous distributions, or even define
a probability distribution on functions. But standard probability theory
cannot support higher-order functions, that is, the category of
measurable spaces is not cartesian closed. <BR/><BR/> Here we introduce
quasi-Borel spaces. We show that these spaces: form a new formalization
of probability theory replacing measurable spaces; form a cartesian
closed category and so support higher-order functions; form an
extensional category and so support good proof principles for equational
reasoning; and support continuous probability distributions. We
demonstrate the use of quasi-Borel spaces for higher-order functions and
probability by: showing that a well-known construction of probability
theory involving random functions gains a cleaner expression; and
generalizing de Finetti’s theorem, that is a crucial theorem in
probability theory, to quasi-Borel spaces.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/kammar-levy-moss-staton-a-monad-for-full-ground-reference-cells.pdf">A
monad for full ground reference cells</a>
</h4>
Ohad Kammar, Paul Blain Levy, Sean Keith Moss, Sam Staton. <BR><BR>
Appears in the <a
href="http://ieeexplore.ieee.org/document/8005109/">32st Annual ACM/IEEE
Symposium on Logic in Computer Science</a>, 2017, <a
href="https://arxiv.org/abs/1702.04908">arXiv:1702.04908</a>, <a
href="https://doi.org/10.1109/LICS.2017.8005109">DOI:
10.1109/LICS.2017.8005109</a>.</li>
</ul>
<blockquote>
<p>“We present a denotational account of dynamic allocation of
potentially cyclic memory cells using a monad on a functor category. We
identify the collection of heaps as an object in a different functor
category equipped with a monad for adding hiding/encapsulation
capabilities to the heaps. We derive a monad for full ground references
supporting effect masking by applying a state monad transformer to the
encapsulation monad. To evaluate the monad, we present a denotational
semantics for a call-by-value calculus with full ground references, and
validate associated code transformations.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/kammar-pretnar-no-value-restriction-is-neede-for-algebraic-effects-and-handlers.pdf">No
value restriction is needed for algebraic effects and handlers</a>
</h4>
Ohad Kammar and Matija Pretnar. <BR><BR> Appears in the <a
href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/div-classtitleno-value-restriction-is-needed-for-algebraic-effects-and-handlersa-hreffn1a-ref-typefnadiv/19DD87AEDAEABBB45A06D5EA21F03428">Journal
of Functional Programming</a>, 2016, <a
href="https://doi.org/10.1017/S0956796816000320">DOI:
10.1017/S0956796816000320</a>.</li>
</ul>
<blockquote>
<p>“We present a straightforward, sound, Hindley-Milner polymorphic type
system for algebraic effects and handlers in a call-by-value calculus,
which, to our surprise, allows type variable generalisation of arbitrary
computations, and not just values. We first recall that the soundness of
unrestricted call-by-value Hindley-Milner polymorphism is known to fail
in the presence of computational effects such as reference cells and
continuations, and that many programming examples can be recast to use
effect handlers instead of these effects. After presenting the calculus
and its soundness proof, formalised in Twelf, we analyse the expressive
power of effect handlers with respect to state effects. We conjecture
handlers alone cannot express reference cells, but show they can
simulate dynamically scoped state, establishing that dynamic binding
also does not need a value restriction.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="http://drops.dagstuhl.de/opus/volltexte/2016/6190/pdf/LIPIcs-CONCUR-2016-1.pdf">Bayesian
inversion by omega-complete cone duality</a>
</h4>
Fredrik Dahlqvist, Vincent Danos, Ilias Garnier, and Ohad Kammar.
<BR><BR> Appears in the <a
href="http://drops.dagstuhl.de/portals/extern/index.php?semnr=16011">The
27th International Conference on Concurrency Theory</a>, 2016.</li>
</ul>
<blockquote>
“The process of inverting Markov kernels relates to the important
subject of Bayesian modelling and learning. In fact, Bayesian update is
exactly kernel inversion. In this paper, we investigate how and when
Markov kernels (aka stochastic relations, or probabilistic mappings, or
simply kernels) can be inverted. We address the question both directly
on the category of measurable spaces, and indirectly by interpreting
kernels as Markov operators:
<ul>
<ul>
<li>
For the direct option, we introduce a typed version of the category of
Markov kernels and use the so-called ‘disintegration of measures’. Here,
one has to specialise to measurable spaces borne from a simple class of
topological spaces -e.g. Polish spaces (other choices are possible). Our
method and result greatly simplify a recent development in Ref. [4].
<li>
For the operator option, we use a cone version of the category of Markov
operators (kernels seen as predicate transformers). That is to say, our
linear operators are not just continuous, but are required to satisfy
the stronger condition of being <span
class="math inline"><em>ω</em></span>-chain-continuous. Prior work shows
that one obtains an adjunction in the form of a pair of contravariant
and inverse functors between the categories of <span
class="math inline"><em>L</em><sub>1</sub></span>- and <span
class="math inline"><em>L</em><sub>∞</sub></span>-cones [3]. Inversion,
seen through the operator prism, is just adjunction. No topological
assumption is needed.
<li>
We show that both categories (Markov kernels and <span
class="math inline"><em>ω</em></span>-chain-continuous Markov operators)
are related by a family of contravariant functors <span
class="math inline"><em>T</em><sub><em>p</em></sub></span> for <span
class="math inline">1 ≤ <em>p</em> ≤ ∞</span>. The <span
class="math inline"><em>T</em><sub><em>p</em></sub></span>’s are Kleisli
extensions of (duals of) conditional expectation functors introduced in
Ref. [3].
<li>
With this bridge in place, we can prove that both notions of inversion
agree when both defined: if <span class="math inline"><em>f</em></span>
is a kernel, and <span class="math inline"><em>f</em><sup>†</sup></span>
its direct inverse, then <span
class="math inline"><em>T</em><sub>∞</sub>(<em>f</em>)<sup>†</sup> = <em>T</em><sub>1</sub>(<em>f</em><sup>†</sup>)</span>.
</ul>
</ul>
<p>”</p>
</blockquote>
<ul>
<li><h4>
<a href="http://arxiv.org/pdf/1601.04943v3">Semantics for probabilistic
programming: higher-order functions, continuous distributions, and soft
constraints</a>
</h4>
Sam Staton, Hongseok Yang, Chris Heunen, Ohad Kammar, and Frank Wood.
<BR><BR> Appears in the <a href="http://arxiv.org/abs/1601.04943">31st
Annual ACM/IEEE Symposium on Logic in Computer Science</a>, 2016, <a
href="https://arxiv.org/abs/1601.04943">arXiv:1601.04943</a>, <a
href="https://doi.org/10.1145/2933575.2935313">DOI:
10.1145/2933575.2935313</a>.</li>
</ul>
<blockquote>
<p>“We study the semantic foundation of expressive probabilistic
programming languages, that support higher-order functions, continuous
distributions, and soft constraints (such as Anglican, Church, and
Venture). We define a metalanguage (an idealised version of Anglican)
for probabilistic computation with the above features, develop both
operational and denotational semantics, and prove soundness, adequacy,
and termination. They involve measure theory, stochastic labelled
transition systems, and functor categories, but admit intuitive
computational readings, one of which views sampled random variables as
dynamically allocated read-only variables. We apply our semantics to
validate nontrivial equations underlying the correctness of certain
compiler optimisations and inference algorithms such as sequential Monte
Carlo simulation. The language enables defining probability
distributions on higher-order functions, and we study their
properties.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="http://www.jstor.org/stable/pdfplus/10.1086/678045.pdf">Inferring
Co-Evolution</a>
</h4>
Ehud Lamm and Ohad Kammar. <BR><BR> Appears in the <a
href="http://www.jstor.org/stable/10.1086/678045">Philosophy of Science,
forthcoming</a>, 2014, <a href="https://doi.org/10.1086/678045">DOI:
10.1086/678045</a>.</li>
</ul>
<blockquote>
<p>“We discuss two inference patterns for inferring the coevolution of
two characters based on their properties at a single point in time and
determine when developmental interactions can be used to deduce
evolutionary order. We discuss the use of the inference patterns we
present in the biological literature and assess the arguments’ validity,
the degree of support they give to the evolutionary conclusion, how they
can be corroborated with empirical evidence, and to what extent they
suggest new empirically addressable questions. We suggest that the
developmental argument is uniquely applicable to cognitive-cultural
coevolution.”</p>
</blockquote>
<ul>
<li><h4>
<a href="publications/kammar-ohad-thesis.pdf">An algebraic theory of
type-and-effect systems</a>
</h4>
Ohad Kammar. <BR><BR> Appears in the <a href="thesis">University of
Edinburgh thesis collection</a>, 2014.</li>
</ul>
<blockquote>
<p>“We present a general semantic account of Gifford-style
type-and-effect systems. These type systems provide lightweight static
analyses annotating program phrases with the sets of possible
computational effects they may cause, such as memory access and
modification, exception raising, and non-deterministic choice. The
analyses are used, for example, to justify the program transformations
typically used in optimising compilers, such as code reordering and
inlining. Despite their existence for over two decades, there is no
prior comprehensive theory of type-and-effect systems accounting for
their syntax and semantics, and justifying their use in effect-dependent
program transformation. We achieve this generality by recourse to the
theory of algebraic effects, a development of Moggi’s monadic theory of
computational effects that emphasises the operations causing the effects
at hand and their equational theory. The key observation is that
annotation effects can be identified with the effect operations. Our
first main contribution is the uniform construction of semantic models
for type-and-effect analysis by a process we call <em>conservative
restriction</em>. Our construction requires an algebraic model of the
unannotated programming language and a relevant notion of predicate. It
then generates a model for Gifford-style type-and-effect analysis. This
uniform construction subsumes existing ad-hoc models for type-and-effect
systems, and is applicable in all cases in which the semantics can be
given via <em>enriched Lawvere theories</em>. Our second main
contribution is a demonstration that our theory accounts for the various
aspects of Gifford-style effect systems. We begin with a version of
Levy’s Call-by-push-value that includes algebraic effects. We add effect
annotations, and design a general type-and-effect system for such
call-by-push-value variants. The annotated language can be thought of as
an intermediate representation used for program optimisation. We relate
the unannotated semantics to the conservative restriction semantics, and
establish the soundness of program transformations based on this effect
analysis. We develop and classify a range of validated transformations,
generalising many existing ones and adding some new ones. We also give
modularly-checkable sufficient conditions for the validity of these
optimisations. <BR/><BR/> In the final part of this thesis, we
demonstrate our theory by analysing a simple example language involving
global state with multiple regions, exceptions, and non-determinism. We
give decision procedures for the applicability of the various
effect-dependent transformations, and establish their soundness and
completeness.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/kammar-lindley-oury-handlers-in-action.pdf">Handlers
in Action</a>
</h4>
Ohad Kammar, Sam Lindley, and Nicolas Oury. <BR><BR> Appears in the <a
href="http://icfpconference.org/icfp2013/">The 18th ACM SIGPLAN
International Conference on Functional Programming</a>, 2013, <a
href="https://doi.org/10.1145/2544174.2500590">DOI:
10.1145/2544174.2500590</a>.</li>
</ul>
<blockquote>
<p>“Plotkin and Pretnar’s handlers for algebraic effects occupy a sweet
spot in the design space of abstractions for effectful computation. By
separating effect signatures from their implementation, alge- braic
effects provide a high degree of modularity, allowing pro- grammers to
express effectful programs independently of the con- crete
interpretation of their effects. A handler is an interpretation of the
effects of an algebraic computation. The handler abstraction adapts well
to multiple settings: pure or impure, strict or lazy, static types or
dynamic types. This is a position paper whose main aim is to popularise
the handler abstraction. We give a gentle introduction to its use, a
col- lection of illustrative examples, and a straightforward operational
semantics. We describe our Haskell implementation of handlers in detail,
outline the ideas behind our OCaml, SML, and Racket implementations, and
present experimental results comparing han- dlers with existing
code.”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/kammar-plotkin-algebraic-foundations-for-effect-dependent-optimisations.pdf">Algebraic
Foundations for Effect-Dependent Optimisations</a>
</h4>
Ohad Kammar and Gordon D. Plotkin. <BR><BR> Appears in the <a
href="http://dl.acm.org/citation.cfm?id=2103698&amp;CFID=912028774&amp;CFTOKEN=32446702">Symposium
on Principles of Programming Languages</a>, 2012, <a
href="https://doi.org/10.1145/2103656.2103698">DOI:
10.1145/2103656.2103698</a>.</li>
</ul>
<blockquote>
<p>” We present a general theory of Gifford-style type and effect
annotations, where effect annotations are sets of effects. Generality is
achieved by recourse to the theory of algebraic effects, a development
of Moggi’s monadic theory of computational effects that emphasises the
operations causing the effects at hand and their equational theory. The
key observation is that annotation effects can be identified with
operation symbols.</p>
</blockquote>
<blockquote>
<p>We develop an annotated version of Levy’s Call-by-Push-Value language
with a kind of computations for every effect set; it can be thought of
as a sequential, annotated intermediate language. We develop a range of
validated optimisations (i.e., equivalences), generalising many existing
ones and adding new ones. We classify these optimisations as structural,
algebraic, or abstract: structural optimisations always hold; algebraic
ones depend on the effect theory at hand; and abstract ones depend on
the global nature of that theory (we give modularly-checkable sufficient
conditions for their validity).”</p>
</blockquote>
<ul>
<li><h4>
<a
href="publications/bacci-danos-kammar-on-the-statistical-thermodynamics-of-communicating-processes.pdf">On
the statistical thermodynamics of reversible communicating processes</a>
</h4>
Giorgio Bacci, Vincent Danos and Ohad Kammar. <BR><BR> Appears in the <a
href="http://calco2011.ecs.soton.ac.uk/">Conference on Algebra and
Coalgebra in Computer Science</a>, 2011, <a
href="https://doi.org/10.1007/978-3-642-22944-2_1">DOI:
10.1007/978-3-642-22944-2_1</a>.</li>
</ul>
<blockquote>
<p>“We propose a probabilistic interpretation of a class of reversible
communicating processes. The rate of forward and backward computing
steps, instead of being given explicitly, is derived from a set of
formal energy parameters. This is similar to the Metropolis-Hastings
algorithm. We find a lower bound on energy costs which guarantees that a
process converges to a probabilistic equilibrium state (a grand
canonical ensemble in statistical physics terms). This implies that such
processes hit a success state in finite average time, if there is
one.”</p>
</blockquote>
<h3>
<a name="preprints"></a>Preprints
</h3>
<ul>
<li><h4>
<a
href="drafts/allais-brady-corbyn-kammar-yallop-frex-dependently-typed-algebraic-simplification.pdf">Frex:
dependently-typed algebraic simplification</a>
</h4>
Guillaume Allais, Edwin Brady, Nathan Corbyn, Ohad Kammar, and Jeremy
Yallop. <BR><BR> Preprint, 2022.</li>
</ul>
<blockquote>
<p>“We present an extensible, mathematically-structured algebraic
simplification library design. We structure the library using universal
algebraic concepts: a free algebra; and a free extension — frex — of an
algebra by a set of variables. The library’s dependently-typed API
guarantees simplification modules, even user-defined ones, are
terminating, sound, and complete with respect to a well-specified class
of equations. Completeness offers intangible benefits in practice — our
main contribution is the novel design. Cleanly separating between the
interface and implementation of simplification modules provides two new
modularity axes. First, simplification modules share thousands of lines
of infrastructure code dealing with term-representation,
pretty-printing, certification, and macros/reflection. Second, new
simplification modules can reuse existing ones. We demonstrate this
design by developing simplification modules for monoid varieties:
ordinary, commutative, and involutive. We implemented this design in the
new Idris2 dependently-typed programming language, and in Agda.”</p>
</blockquote>
<ul>
<li><h4>
<a href="drafts/kammar-locally-determined-colimits.pdf">An absolute
characterisation of locally determined omega-colimits</a>
</h4>
Ohad Kammar. <BR><BR> Preprint, 2014, <a
href="https://arxiv.org/abs/1508.05072">arXiv:1508.05072</a>.</li>
</ul>
<blockquote>
<p>“Characterising colimiting omega-cocones of projection pairs in terms
of least upper bounds of their embeddings and projections is important
to the solution of recursive domain equations. We present a universal
characterisation of this local property as omega-cocontinuity of locally
continuous functors. We present a straightforward proof using the
enriched Yoneda embedding. The proof can be generalised to Cattani and
Fiore’s notion of locality for adjoint pairs.”</p>
</blockquote>
<h3>
<a name="talks"></a>Talks
</h3>
<ul>
<li><h4>
<a href="talks/mfps-2025-mast-slides.pdf">Modular abstract syntax trees
(MAST): substitution tensors with second-class sorts</a>
</h4>
Talk given at the <a
href="https://www.coalg.org/calco-mfps-2025/mfps/">41st Conference on
Mathematical Foundations of Programming Semantics MFPS XLI (MFPS
2025)</a>, 04 June, 2025.</li>
</ul>
<blockquote>
<p>We adapt Fiore, Plotkin, and Turi’s treatment of abstract syntax with
binding, substitution, and holes to account for languages with
second-class sorts. These situations include programming calculi such as
the Call-by-Value 𝜆-calculus (CBV) and Levy’s Call-by-Push-Value (CBPV).
Prohibiting second-class sorts from appearing in variable contexts means
the presheaf of variables is no longer a left-unit for Fiore et al’s
substitution tensor product. We generalise their development to
associative and right-unital skew monoidal categories. We reuse much of
the development through skew bicategorical arguments. We apply the
resulting theory by proving substitution lemmata for varieties of CBV
modularly. Joint work with Marcelo Fiore, Georg Moser, and Sam
Staton.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/spls-2025-mast.pdf">Modular abstract syntax trees (MAST):
substitution tensors with second-class sorts</a>
</h4>
Talk given at the <a
href="https://spli.scot/spls/meetings/2025/june/">Scottish Programming
Languages Seminar</a>, 04 June, 2025.</li>
</ul>
<blockquote>
<p>We adapt Fiore, Plotkin, and Turi’s treatment of abstract syntax with
binding, substitution, and holes to account for languages with
second-class sorts. These situations include programming calculi such as
the Call-by-Value 𝜆-calculus (CBV) and Levy’s Call-by-Push-Value (CBPV).
Prohibiting second-class sorts from appearing in variable contexts means
the presheaf of variables is no longer a left-unit for Fiore et al’s
substitution tensor product. We generalise their development to
accommodate second-class sorts, and reuse much of the development
through bicategorical arguments. We apply the resulting theory by
proving substitution lemmata for varieties of CBV modularly. Joint work
with Marcelo Fiore, Georg Moser, and Sam Staton.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="">A Type-Driven Overview of Probabilistic Programming</a>
</h4>
Talk given at the University of Tartu Programming Languages Research
Seminar, 28 October, 2024.</li>
</ul>
<blockquote>
<p>Probabilistic programming (ProbProg) is a statistical modelling
discipline that uses programming language constructs to define
probabilistic models. The approach ProbProg takes is particularly
appealing for conditioning a model on observed data, which has a global
effect on the model. In this informal talk I will introduce the ProbProg
approach. I will mix some historical and more recent developments, by
myself and others. I will use types to make the discussion more
precise.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/kammar-mfps-2024-tdpm.pdf">Semantic foundations for
type-driven probabilistic modelling</a>
</h4>
Talk given at the <a
href="https://oxford24.github.io/all-talks.html">40th International
Conference on Mathematical Foundations of Programming Semantics
(MFPS’24)</a>, 21 June, 2024.</li>
</ul>
<blockquote>
<p>The last few years have seen several breakthroughs in the semantic
foundations of probabilistic and statistical modelling. Types show clear
promise in organising intricate models and the inference algorithms we
use to fit them to data. I will present a type-rich and straightforward
model, the quasi Borel space, and survey recent and ongoing developments
in this area.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/kammar-moser-next-hope23.pdf">Semantic foundations of
potential-synthesis for expected amortised-cost analysis</a>
</h4>
Talk given at the <a
href="https://icfp23.sigplan.org/details/hope-2023/6/Semantic-foundations-of-potential-synthesis-for-expected-amortised-cost-analysis">11th
ACM SIGPLAN Workshop on Higher-Order Programming with Effects
(HOPE’23)</a>, 04 September, 2023.</li>
</ul>
<blockquote>
<p>We describe ongoing work developing a semantic infrastructu re for
designing automated and interactive amortised cost analyses based on
synthesising potential functions for randomised data structures. These
analyses can synthesise amortised complexity bounds that are tight and
correct by construction. The architecture combines established and
recent ideas from program logics for data structure specification,
weakest pre-condition quantitative reasoning, semantics of probabilistic
programming, and amortised resource analysis synthesis.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/frex-wg2.11-2022.pdf">Frex: staged-optimisation and
equational-proof-synthesis using universal algebra</a>
</h4>
Talk given at the <a
href="https://wiki.hh.se/wg211/index.php/WG211/M21Schedule">21st meeting
of IFIP Working Group 2.11: Program Generation</a>, 16 August,
2022.</li>
</ul>
<blockquote>
<p>A recurring task in program generation involves developing
data-structures representing semantically-distinct code fragments. We
can stage an optimised version of the original program off of its
representation. Moreover, we may want to extract the detailed steps in
the equational proof that the representation is equivalent to its
source. These representations are known as partially-static data
structures and semantic normal-forms. In recent and ongoing work, we
specify these data structures using universal algebraic concepts, the
free algebra and its less familiar sibling the free extension. In this
talk, I’ll review our application of free extensions to
staged-optimisation and proof-synthesis. Depending on audience
participation, I’ll either delve further into applications, give a
tutorial on designing data structures based on free extensions, or
sketch future directions.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/2022-cirm-higher-order-measure-theory.pdf">An
introduction to statistical modelling semantics with higher-order
measure theory</a>
</h4>
Talk given at the <a
href="https://conferences.cirm-math.fr/2686.html">Logic of Probabilistic
Programming</a>, see <a href="qbs-splv-2022">course webpage</a> for
latest recordings and exercise sheets, 03 February, 2022.</li>
</ul>
<blockquote>
<p>The last few years have seen several breakthroughs in the semantic
foundations of statistical modelling. In this tutorial, I will introduce
one of these approaches — quasi Borel spaces. We will review and develop
a semantic tool-kit for measure theory using higher-order functions. We
will apply it to the semantic foundations of generative Bayesian
modelling.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/spls2021-frex/SPLS2021.idr">Frex: dependently-typed
algebraic simplification</a>
</h4>
Talk given at the <a
href="https://spls-series.github.io/meetings/2021/october/">Scottish
Programming Languages Seminar</a>, 20 October, 2021.</li>
</ul>
<blockquote>
<p>(joint work with Guillaume Allais, Edwin Brady, Nathan Corbyn, and
Jeremy Yallop) I’ll present an extensible, mathematically-structured
algebraic simplification library design. We structure the library using
universal algebraic concepts: a free algebra; and a free extension —
frex — of an algebra by a set of variables. The latter concept, the
frex, generalises the
<code>ring of polynomials over a ring' to that of</code>an algebra of
polynomials over an algebra`. The library’s dependently-typed API
guarantees that the simplification modules in the library, even
user-defined ones, are terminating, sound, and complete with respect to
a well-specified class of equations. Our design is modular in two axes.
First, simplification modules share thousands of lines of infrastructure
code dealing with term-representation, pretty-printing, certification,
and macros/reflection. Second, more advanced simplification modules can
reuse existing simplification modules. We demonstrate this design by
developing three monoid simplification modules: ordinary, commutative,
and involutive monoids. We implemented this design in the new Idris2
dependently-typed programming language, and in Agda. I will demonstrate
the Idris2 implementation.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/unworkshop-ideas-2021.pdf">Where do ideas come from?</a>
</h4>
Talk given at the <a
href="https://unworkshop.science/21-08-17-where-do-ideas-come-from">Mental
Strength for Science Unworkshop</a>, 17 August, 2021.</li>
</ul>
<blockquote>
<p>We are in the ideas business: collecting, fleshing out, developing,
and communicating them. I will discuss the life-cycle of (my) ideas, and
give some pragmatic advice on managing and cultivating them.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/IDM2021.idr">Tutorial: equational reasoning and
rewriting</a>
</h4>
Talk given at the <a
href="https://github.com/idris-lang/Idris2/wiki/Idris-Developers-Meeting%2C-April-2021">Idris
Developers Meeting 2021</a>, 28 February, 2021.</li>
</ul>
<blockquote>
<p>When we use dependent types, we sometimes need to convince Idris that
two terms are equal. When this argument requires more than a couple of
steps, it’s more readable to use equational reasoning instead to justify
this equality. In this tutorial, I’ll explain the current equational
reasoning standard library, so that you could do it yourself when you
need to. I will also highlight contributions that will improve
equational reasoning, and mention some ongoing work involving
equations.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/pihoc-2021-building-blocks.pdf">Higher-order building
blocks for statistical modelling</a>
</h4>
Talk given at the <a
href="https://www.irif.fr/pps-pihoc-diapason2021">PPS-PIHOC-DIAPASoN
Workshop</a>, 17 February, 2021.</li>
</ul>
<blockquote>
<p>Higher-order functions provide modular programmable abstractions,
even if the resulting program is first-order. The PIHOC community have
produced several breakthroughs in the foundations for higher-order
probability in recent years, enabling us to formulate and manipulate
these abstractions for statistical modelling. I will use quasi-Borel
spaces to discuss such higher-order building blocks in existing and
ongoing work in semantic foundations for statistical modelling,
including operational, denotational, and axiomatic semantics, and the
design and implementation of statistical inference and simulation
systems.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/huawei-2021-intro-to-probprog.pdf">An introduction to
ProbProg</a>
</h4>
Talk given at the Huawei Tech-Talk, Huawei Edinburgh Research Centre, 14
January, 2021.</li>
</ul>
<blockquote>
<p>Probabilistic programming is a collection of techniques for
expressing and analysing statistical models as programs. I will present
a high-level introduction to ProbProg aimed at compiler engineers and
programming language researchers. We’ll go over a few probabilistic
programs, and discuss broad questions such as: When might a
probabilistic program be appropriate? How they might be used inside a
bigger program? What operations might be ‘expensive’? What do ProbProgs
‘compute’? and what happens under the hood in an inference engine?</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a
href="talks/FMF2020-frex-indexing-modulo-equations-using-free-extensions.idr">Frex:
indexing-modulo-equations with free extensions</a>
</h4>
Talk given at the <a
href="https://www.fmf.uni-lj.si/si/obvestila/57122/">Seminar on the
Foundations of Mathematics and Theoretical Computing</a>, <a
href="https://www.fmf.uni-lj.si/en/">Faculty of Mathematics and
Physics</a>, <a href="https://www.uni-lj.si/eng/">University of
Ljubljana</a>, 15 October, 2020.</li>
</ul>
<blockquote>
<p>Joint work with Guillaume Allais, Edwin Brady, and Jeremy Yallop.
<BR/> I’ll report about ongoing work on an extensible dependently-typed
library of algebraic solvers for common algebraic structures based on
free extensions (frex): the coproduct of an algebra with a free algebra.
One challenge arising when programming with types indexed by values
involves convincing the type-checker that two open terms are equal, as
variables appearing in open terms get in the way of standard
normalisation procedures like beta-reduction. <BR/> Here I’ll focus on
indexing by terms amenable to equational reasoning. When the indexing
type is the carrier for an algebraic structure, we hypothesise that
type-checking modulo this theory amounts to representing the free
extension of the algebra structure of this type with a finite set of
variables. We propose a library involving two tiers: a user-facing tier
for indexing types with algebraic values (‘frexlets’), and a
library-developer-facing tier for extending the library to support new
algebraic theories (‘core frex’). I’ll report and demonstrate our
implementation in Brady’s upcoming Idris2 programming language.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a
href="talks/PLUG2020-frex-indexing-modulo-equations-using-free-extensions.idr">Frex:
indexing-modulo-equations with free extensions</a>
</h4>
Talk given at the <a
href="https://samoa.dcs.gla.ac.uk/events/series.jsp?series=123">Programming
Languages at University of Glasgow (PLUG) Seminar</a>, <a
href="https://www.gla.ac.uk/schools/computing/">School of Computing
Science</a>, <a href="https://www.gla.ac.uk/">University of Glasgow</a>,
13 October, 2020.</li>
</ul>
<blockquote>
<p>Joint work with Guillaume Allais, Edwin Brady, and Jeremy Yallop.
<BR/> I’ll report about ongoing work on an extensible dependently-typed
library of algebraic solvers for common algebraic structures based on
free extensions (frex): the coproduct of an algebra with a free algebra.
One challenge arising when programming with types indexed by values
involves convincing the type-checker that two open terms are equal, as
variables appearing in open terms get in the way of standard
normalisation procedures like beta-reduction. <BR/> Here I’ll focus on
indexing by terms amenable to equational reasoning. When the indexing
type is the carrier for an algebraic structure, we hypothesise that
type-checking modulo this theory amounts to representing the free
extension of the algebra structure of this type with a finite set of
variables. We propose a library involving two tiers: a user-facing tier
for indexing types with algebraic values (‘frexlets’), and a
library-developer-facing tier for extending the library to support new
algebraic theories (‘core frex’). I’ll report and demonstrate our
implementation in Brady’s upcoming Idris2 programming language.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/kammar-mfps-2020-probprog-taxonomy.pdf">A ProbProg
Language Taxonomy</a>
</h4>
Talk given at the <a
href="https://www.monoidal.net/paris2020/mfps/schedule.html#ss">36th
International Conference on Mathematical Foundations of Programming
Semantics (MFPS’20)</a> Special Session on Probabilistic Programming, 05
June, 2020.</li>
</ul>
<blockquote>
<p>Modern probabilistic programming languages come in many flavours. In
this talk I will propose two axes for comparing and contrasting these
flavours through their statistical modelling primitives, and describe
work-in-progress building semantic bridges between these flavours.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="drafts/lola19-perspective-on-ohearn-ricke.pdf">A modern
perspective on the O’Hearn-Reicke model</a>
</h4>
Talk given at the Syntax and Semantics of Low-Level Languages (<a
href="http://cs.appstate.edu/~johannp/lola19/">LOLA’19</a>), 23 June,
2019.</li>
</ul>
<blockquote>
<p>O’Hearn and Riecke gave an extensional fully abstract model of PCF.
The construction uses concrete logical relations of varying arity
(unary, binary, ternary, etc.) to remove junk from the extensional
domain-theoretic model. In ongoing work, we recast their model using
modern semantic machinery, such as monads and their algebras, monadic
lifting, and definability by TT-closure. We review the model from this
perspective, and report on our progress.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/lmw-ideas-2019.pdf">Where do ideas come from?</a>
</h4>
Talk given at the <a href="https://lics.siglog.org/lics19/lmw.php">4th
Logic Mentoring Workshop</a>, affiliated with <a
href="https://lics.siglog.org/lics19/index.php">LICS’19</a>, 11 April,
2019.</li>
</ul>
<blockquote>
<p>We are in the ideas business: collecting, fleshing out, developing,
and communicating them. I will discuss the life-cycle of (my) ideas, and
give some pragmatic advice on managing and cultivating them.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="">[Eff-Bayes: modular implementations of approximate Bayesian
inference with effect
handlers](https://github.com/ohad/eff-bayes/tree/master/slides/kaist)</a>
</h4>
Talk given at the <a href="https://cs.kaist.ac.kr">School of
Computing</a>, <a href="https://www.kaist.ac.kr/">KAIST</a>, 11 April,
2019.</li>
</ul>
<blockquote>
<p>Abstract: I will describe work-in-progress, implementing a library
for Bayesian inference algorithms for statistical probabilistic
programming in the programming language Eff using algebraic effects and
handlers. During the demonstration, I will introduce both programming
with effects handlers and probabilistic programming. <BR/> Joint work
with Matija Pretnar, Žiga Lukšič, Oliver Goldstein, and Adam
Ścibior.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="">[A tutorial on quasi-Borel
spaces](https://www.cs.ubc.ca/event/2019/03/tutorial-quasi-borel-spaces-ohad-kammar-university-edinburgh)</a>
</h4>
Talk given at the <a href="https://www.cs.ubc.ca/">Department of
Computer Science</a>, <a href="http://www.ubc.ca/">the University of
British Columbia</a>, 22 March, 2019.</li>
</ul>
<blockquote>
<p>We have used Quasi-Borel spaces, a new mathematical structure, as a
foundations of probabilistic programming and higher-order statistics. In
this informal talk, I will introduce this alternative to traditional
measure theory. We will cover the basic definition, and the
constructions relevant to modelling and verification.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="">A tutorial on quasi-Borel spaces</a>
</h4>
Talk given at the Workshop on Higher-order probabilistic computation, <a
href="http://www.mcgill.ca/bellairs/">Bellairs Research Institute</a>,
17 March, 2019.</li>
</ul>
<blockquote>
<p>We have used Quasi-Borel spaces, a new mathematical structure, as a
foundations of probabilistic programming and higher-order statistics. In
this informal talk, I will introduce this alternative to traditional
measure theory. We will cover the basic definition, and the
constructions relevant to modelling and verification.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="">[Eff-Bayes: modular implementations of approximate Bayesian
inference with effect
handlers](https://github.com/ohad/eff-bayes/tree/master/slides/spls-st-andrews-2019)</a>
</h4>
Talk given at the <a
href="http://www.dcs.gla.ac.uk/research/spls/">Scottish Programming
Language Seminar</a>, <a href="http://www.st-andrews.ac.uk/">University
of St. Andrews</a> School of Computer
Science](https://www.cs.st-andrews.ac.uk/), 13 March, 2019.</li>
</ul>
<blockquote>
<p>I will describe work-in-progress, implementing a library for Bayesian
inference algorithms for statistical probabilistic programming in the
programming language Eff using algebraic effects and handlers. <BR/>
Joint work with Matija Pretnar, Žiga Lukšič, Oliver Goldstein, and Adam
Ścibior.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/cambridge-lns-2019-wqbs.pdf">A domain theory for
statistical probabilistic programming</a>
</h4>
Talk given at the <a
href="http://talks.cam.ac.uk/talk/index/118606">Logic and Semantics
Seminar</a>, <a
href="http://www.cl.cam.ac.uk/research/pls/">Programming, Logic, and
Semantics Group</a>, <a href="http://www.cam.ac.uk">University of
Cambridge</a> <a href="http://www.cl.cam.ac.uk">Computer Laboratory</a>,
22 February, 2019.</li>
</ul>
<blockquote>
<p>I will describe our recent work on statistical probabilistic
programming languages. These are expressive languages for describing
generative Bayesian models of the kinds used in computational statistics
and machine learning. We give an adequate denotational semantics for a
calculus with recursive higher-order types, continuous probability
distributions, and soft constraints. Among them are untyped languages,
similar to Church and WebPPL, because our semantics allows recursive
mixed-variance datatypes. Our semantics justifies important program
equivalences including commutativity. <BR/> Our new semantic model is
based on `quasi-Borel predomains’. These are a mixture of chain-complete
partial orders (cpos) and quasi-Borel spaces. Quasi-Borel spaces are a
recent model of probability theory that focuses on sets of admissible
random elements. I will give a brief introduction to quasi-Borel spaces
and predomains, and their properties. <BR/> Probability is traditionally
treated in cpo models using probabilistic powerdomains, but these are
not known to be commutative on any class of cpos with higher-order
functions. By contrast, quasi-Borel predomains do support both a
commutative probabilistic powerdomain and higher-order functions, which
I will describe. <BR/> For more details on this joint work with Matthijs
Vákár and Sam Staton, see: <BR/> Matthijs Vákár, Ohad Kammar, and Sam
Staton. 2019. A Domain Theory for Statistical Probabilistic Programming.
Proc. ACM Program. Lang. 3, POPL, Article 36 (January 2019), 35 pages.,
DOI: 10.1145/3290349.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/fmf-2019.pdf">A domain theory for statistical
probabilistic programming</a>
</h4>
Talk given at the <a
href="https://www.fmf.uni-lj.si/si/obvestila/49879/">Seminar za temelje
matematike in teoretično računalništvo</a>, <a
href="http://www.fmf.uni-lj.si/">Faculty of Mathematics and Physics</a>,
<a href="http://www.uni-lj.si/">University of Ljubljana</a>, 14
February, 2019.</li>
</ul>
<blockquote>
<p>I will describe our recent work on statistical probabilistic
programming languages. These are expressive languages for describing
generative Bayesian models of the kinds used in computational statistics
and machine learning. We give an adequate denotational semantics for a
calculus with recursive higher-order types, continuous probability
distributions, and soft constraints. Among them are untyped languages,
similar to Church and WebPPL, because our semantics allows recursive
mixed-variance datatypes. Our semantics justifies important program
equivalences including commutativity. <BR/> Our new semantic model is
based on `quasi-Borel predomains’. These are a mixture of chain-complete
partial orders (cpos) and quasi-Borel spaces. Quasi-Borel spaces are a
recent model of probability theory that focuses on sets of admissible
random elements. I will give a brief introduction to quasi-Borel spaces
and predomains, and their properties. <BR/> Probability is traditionally
treated in cpo models using probabilistic powerdomains, but these are
not known to be commutative on any class of cpos with higher-order
functions. By contrast, quasi-Borel predomains do support both a
commutative probabilistic powerdomain and higher-order functions, which
I will describe. <BR/> For more details on this joint work with Matthijs
Vákár and Sam Staton, see: <BR/> Matthijs Vákár, Ohad Kammar, and Sam
Staton. 2019. A Domain Theory for Statistical Probabilistic Programming.
Proc. ACM Program. Lang. 3, POPL, Article 36 (January 2019), 35 pages.,
DOI: 10.1145/3290349.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/pihoc2019-wqbs.pdf">A domain theory for statistical
probabilistic programming</a>
</h4>
Talk given at the Second Workshop on <a
href="http://pihoc2019.cs.unibo.it/">Probabilistic Interactive and
Higher-Order Computation (PIHOC)</a>, 07 February, 2019.</li>
</ul>
<blockquote>
<p>I will describe our recent work on statistical probabilistic
programming languages. These are expressive languages for describing
generative Bayesian models of the kinds used in computational statistics
and machine learning. We give an adequate denotational semantics for a
calculus with recursive higher-order types, continuous probability
distributions, and soft constraints. Among them are untyped languages,
similar to Church and WebPPL, because our semantics allows recursive
mixed-variance datatypes. Our semantics justifies important program
equivalences including commutativity. <BR/> Our new semantic model is
based on `quasi-Borel predomains’. These are a mixture of chain-complete
partial orders (cpos) and quasi-Borel spaces. Quasi-Borel spaces are a
recent model of probability theory that focuses on sets of admissible
random elements. I will give a brief introduction to quasi-Borel spaces
and predomains, and their properties. <BR/> Probability is traditionally
treated in cpo models using probabilistic powerdomains, but these are
not known to be commutative on any class of cpos with higher-order
functions. By contrast, quasi-Borel predomains do support both a
commutative probabilistic powerdomain and higher-order functions, which
I will describe. <BR/> For more details on this joint work with Matthijs
Vákár and Sam Staton, see: <BR/> Matthijs Vákár, Ohad Kammar, and Sam
Staton. 2019. A Domain Theory for Statistical Probabilistic Programming.
Proc. ACM Program. Lang. 3, POPL, Article 36 (January 2019), 35 pages.,
DOI: 10.1145/3290349.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/lsv2019-wqbs.pdf">A domain theory for statistical
probabilistic programming</a>
</h4>
Talk given at the <a
href="http://www.lsv.fr/Seminaires/?sem=201901291100">LSV Seminar</a>,
<a href="http://www.lsv.fr/">Laboratoire Spécification et
Vérification</a>, <a href="http://ens-paris-saclay.fr/">École normale
supérieure Paris-Saclay</a>, Paris, 29 January, 2019.</li>
</ul>
<blockquote>
<p>I will describe our recent work on statistical probabilistic
programming languages. These are expressive languages for describing
generative Bayesian models of the kinds used in computational statistics
and machine learning. We give an adequate denotational semantics for a
calculus with recursive higher-order types, continuous probability
distributions, and soft constraints. Among them are untyped languages,
similar to Church and WebPPL, because our semantics allows recursive
mixed-variance datatypes. Our semantics justifies important program
equivalences including commutativity. <BR/> Our new semantic model is
based on `quasi-Borel predomains’. These are a mixture of chain-complete
partial orders (cpos) and quasi-Borel spaces. Quasi-Borel spaces are a
recent model of probability theory that focuses on sets of admissible
random elements. I will give a brief introduction to quasi-Borel spaces
and predomains, and their properties. <BR/> Probability is traditionally
treated in cpo models using probabilistic powerdomains, but these are
not known to be commutative on any class of cpos with higher-order
functions. By contrast, quasi-Borel predomains do support both a
commutative probabilistic powerdomain and higher-order functions, which
I will describe. <BR/> For more details on this joint work with Matthijs
Vákár and Sam Staton, see: <BR/> Matthijs Vákár, Ohad Kammar, and Sam
Staton. 2019. A Domain Theory for Statistical Probabilistic Programming.
Proc. ACM Program. Lang. 3, POPL, Article 36 (January 2019), 35 pages.,
DOI: 10.1145/3290349.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/hope2018-wqbs.pdf">A domain theory for statistical
probabilistic programming</a>
</h4>
Talk given at the 7th ACM SIGPLAN Workshop on Higher-Order Programming
with Effects, 23 September, 2018.</li>
</ul>
<blockquote>
<p>We describe ongoing work investigating a convenient category of
predomains and a probabilistic powerdomain construction suitable for
statistical probabilistic programming semantics, as used in statistical
modelling and machine learning. Our goal is to give adequate semantics
to a probabilistic higher-order language with recursive types, and
includes types for powers of real numbers and arbitrary measurable
functions between them. <BR/><BR/> Specifically, we provide (1) a
cartesian closed category; (2) whose objects are (pre)-domains; and (3)
a commutative monad for continuous probabilistic choice and Bayesian
conditioning. Jones and Plotkin have shown that conditions (2)–(3) hold
when one restricts attention to continuous domains, and Jung and Tix
have proposed to search for a suitable category of continuous domains
possessing all three properties (1)–(3), a question that remains open to
date. <BR/><BR/> We propose an alternative direction, considering spaces
with separate, but compatible, measure-theoretic and domain-theoretic
structures. On the domain-theoretic side, we require posets with suprema
of countably increasing chains (omega-cpos). On the measure-theoretic
side, we require a quasi-Borel space (qbs) structure, a recently
introduced algebraic structure suitable for modelling higher-order
probability theory. There are three equivalent characterisations of this
category given by: imposing an order-theoretic separatedness condition
on countable-product-preserving omega-cpo-valued contra-variant
functors; internal omega-cpos in the quasi-topos of quasi-Borel spaces;
and an essentially algebraic presentation. The category of these
omega-qbses validates Fiore and Plotkin’s axiomatic domain theory,
yielding semantics for recursive types. We construct a commutative
powerdomain construction by factorising the Lebesgue integral from the
space of random elements to the space of countably additive linear
integration operators. <BR/><BR/> Joint work with Sam Staton and
Matthijs Vákár</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/kammar-vakar-staton-domains2018-qbs.pdf">A domain theory
for quasi-Borel spaces and statistical probabilistic programming</a>
</h4>
Talk given at the invited talk, International Workshop on Domain Theorey
and its Applications, 08 July, 2018.</li>
</ul>
<blockquote>
<p>I will describe ongoing work investigating a convenient category of
pre-domains and a probabilistic powerdomain construction suitable for
statistical probabilistic programming semantics, as used in statistical
modelling and machine learning. Specifically, we provide (1) a cartesian
closed category; (2) whose objects are (pre)-domains; and (3) a
commutative monad for probabilistic choice and Bayesian conditioning.
Jones and Plotkin have shown that conditions (2)–(3) hold when one
restricts attention to continuous domains, and Jung and Tix have
proposed to search for a suitable category of continuous domains
possessing all three properties (1)–(3), a question that remains open to
date. <BR/><BR/> I propose an alternative direction, considering spaces
with separate, but compatible, measure-theoretic and domain-theoretic
structures. On the domain-theoretic side, we require posets with suprema
of countably increasing chains (omega-cpos). On the measure-theoretic
side, we require a quasi-Borel space (qbs) structure, a recently
introduced algebraic structure suitable for modelling higher-order
probability theory. There are three equivalent characterisations of this
category given by: imposing an order-theoretic separatedness condition
on countable-preserving omega-cpo-valued presheaves; internal omega-cpos
in the quasi-topos of quasi-Borel spaces; and an essentially algebraic
presentation. The category of these omega-qbses validates Fiore and
Plotkin’s axiomatic domain theory, yielding semantics for recursive
types. To conclude, I will describe a commutative powerdomain
construction given by factorising the Lebesgue integral from the space
of random elements to the space of sigma-linear integration
operators</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/kammar-levy-moss-staton-ref-cells-fau.pdf">A monad for
full ground reference cells</a>
</h4>
Talk given at the Theoretische Informatik Seminar, Department of
Computer Science, Faculty of Engineering,
Friedrich-Alexander-Universität Erlangen-Nürnberg, 25 June, 2018.</li>
</ul>
<blockquote>
<p>I will describe how to build a monad on a functor category to model
dynamic allocation of potentially cyclic memory cells. In particular
I’ll explain how to tackle the challenge of ‘effect masking’ which means
roughly that ‘if you don’t need to know about memory access then you
can’t detect it.’, and use this monad to give a denotational account of
an ML-like language with reference cells, and validate associated
program transformations. <BR/><BR/> I will explain the main insight
behind our construction: identifying the collection of stores as an
object in a different functor category equipped with a monad for adding
hiding/encapsulation capabilities to the stores. I will then obtain the
full ground storage monad by applying a state monad transformer to the
encapsulation monad. <BR/><BR/> The talk is based on work with: Paul B.
Levy, Sean K. Moss, and Sam Staton (<a
href="http://arxiv.org/abs/1702.04908">http://arxiv.org/abs/1702.04908</a>)</p>
</blockquote>
<P/>
<ul>
<li><h4>
<p><a href="talks/quandum-day-2018-wqbs.pdf">A domain theory for
quasi-Borel spaces</a></p>
</h4>
<p>Talk given at the Oxford Quantum Day 2018, 19 June, 2018.</p>
<P/></li>
<li><h4>
<p><a href="talks/dagstuhl-2018-inference.pdf">Modular Bayesian
inference</a></p>
</h4>
<p>Talk given at the <a href="http://www.dagstuhl.de/18172">Dagstuhl
seminar 18172: algebraic effects go mainstream</a>, 24 April,
2018.</p></li>
</ul>
<blockquote>
<p>A brief overview of probabilistic programming for statistical
modelling and machine learning. Report on recent advances in the modular
validation of similarly modular implementations of generic Bayesian
inference algorithms such as Sequential Monte Carlo and Trace Markov
Chain Monte Carlo. Report on ongoing work on a Haskell implementation of
these ideas and its performance evaluation with respect to existing
probabilistic programming systems. <BR/><BR/> Joint with Adam Ścibior,
Matthijs Vákár, Sam Staton, Hongseok Yang, Yufei Cai, Klaus Ostermann,
Zoubin Ghahramani, Sean K. Moss, and Chris Heunen.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/imperial-2018-inference.pdf">Denotational validation of
Bayesian inference</a>
</h4>
Talk given at the <a href="http://mrg.doc.ic.ac.uk/">Mobility Reading
Group Seminar</a>, <a href="http://www.doc.ic.ac.uk/">Department of
Computing</a>, <a href="http://www.ic.ac.uk/">Imperial College
London</a>, 11 April, 2018.</li>
</ul>
<blockquote>
<p>I will present a semantic account of Bayesian inference algorithms
for probabilistic programming languages, as used in Bayesian data
science and machine learning. Sophisticated inference algorithms are
often explained in terms of composition of smaller parts. However,
neither their theoretical justification nor their implementation reflect
this modularity. I will show how to conceptualise and analyse such
inference algorithms as manipulating intermediate representations of
probabilistic programs using higher-order functions and inductive types,
and their denotational semantics. <BR/><BR/> Semantic accounts of
continuous distributions use measurable spaces. However, this use of
higher-order functions presents a substantial technical difficulty: it
is impossible to define a measurable space structure over the collection
of measurable functions between arbitrary measurable spaces that is
compatible with standard operations on those functions, such as
application. I will explain how to overcome this difficulty using
quasi-Borel spaces, a recently proposed mathematical structure that
supports both function spaces and continuous distributions. To make the
semantic manipulation closer to its traditional measure theoretic
origins, I will review and use Kock’s synthetic measure theory. This
notation was useful for proving a quasi-Borel counterpart to the
Metropolis-Hastings-Green theorem. <BR/><BR/> Joint with Adam Ścibior,
Matthijs Vákár, Sam Staton, Hongseok Yang, Yufei Cai, Klaus Ostermann,
Zoubin Ghahramani, Sean K. Moss, and Chris Heunen.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/pihoc.pdf">Quasi-Borel spaces and the validation of
Bayesian inference algorithms</a>
</h4>
Talk given at the <a href="http://pihoc2018.cs.unibo.it/">Workshop on
Probabilistic Interactive and Higher-Order Computation (PIHOC)</a>, 22
February, 2018.</li>
</ul>
<blockquote>
<p>I will present a semantic account of Bayesian inference algorithms
for probabilistic programming languages, as used in Bayesian data
science and machine learning. Sophisticated inference algorithms are
often explained in terms of composition of smaller parts. However,
neither their theoretical justification nor their implementation reflect
this modularity. I will show how to conceptualise and analyse such
inference algorithms as manipulating intermediate representations of
probabilistic programs using higher-order functions and inductive types,
and their denotational semantics. <BR/><BR/> Semantic accounts of
continuous distributions use measurable spaces. However, this use of
higher-order functions presents a substantial technical difficulty: it
is impossible to define a measurable space structure over the collection
of measurable functions between arbitrary measurable spaces that is
compatible with standard operations on those functions, such as
application. I will explain how to overcome this difficulty using
quasi-Borel spaces, a recently proposed mathematical structure that
supports both function spaces and continuous distributions. To make the
semantic manipulation closer to its traditional measure theoretic
origins, I will review and use Kock’s synthetic measure theory. This
notation was useful for proving a quasi-Borel counterpart to the
Metropolis-Hastings-Green theorem. <BR/><BR/> Joint with Adam Ścibior,
Matthijs Vákár, Sam Staton, Hongseok Yang, Yufei Cai, Klaus Ostermann,
Zoubin Ghahramani, Sean K. Moss, and Chris Heunen.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a
href="talks/forster-kammar-lindley-pretnar-expresiveness-icfp17.pdf">On
the expressive power of user-defined effects: effect handlers, monadic
reflection, delimited control</a>
</h4>
Talk given at the <a
href="http://icfp17.sigplan.org/track/icfp-2017-papers#event-overview">22nd
ACM SIGPLAN International Conference on Functional Programming</a>, 04
September, 2017.</li>
</ul>
<blockquote>
<p>We compare the expressive power of three programming abstractions for
user-defined computational effects: Bauer and Pretnar’s effect handlers,
Filinski’s monadic reflection, and delimited control without
answer-type-modification. This comparison allows a precise discussion
about the relative expressiveness of each programming abstraction. It
also demonstrates the sensitivity of the relative expressiveness of
user-defined effects to seemingly orthogonal language features.
<BR/><BR/> We present three calculi, one per abstraction, extending
Levy’s call-by-push-value. For each calculus, we present syntax,
operational semantics, a natural type-and-effect system, and, for effect
handlers and monadic reflection, a set-theoretic denotational semantics.
We establish their basic meta-theoretic properties: safety, termination,
and, where applicable, soundness and adequacy. Using Felleisen’s notion
of a macro translation, we show that these abstractions can
macro-express each other, and show which translations preserve
typeability. We use the adequate finitary set-theoretic denotational
semantics for the monadic calculus to show that effect handlers cannot
be macro-expressed while preserving typeability either by monadic
reflection or by delimited control. We supplement our development with a
mechanised Abella formalisation.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/plume-inference-2017.pdf">Denotational validation of
Bayesian inference</a>
</h4>
Talk given at the <a href="http://www.ens-lyon.fr/LIP/PLUME/">Séminaire
PLUME</a> <a href="http://www.ens-lyon.fr">École normale supérieure de
Lyon</a>, 12 July, 2017.</li>
</ul>
<blockquote>
<p>I will present a semantic account of Bayesian inference algorithms
for probabilistic programming languages, as used in Bayesian data
science and machine learning. Sophisticated inference algorithms are
often explained in terms of composition of smaller parts. However,
neither their theoretical justification nor their implementation
reflects this modularity. I will show how to conceptualise and analyse
such inference algorithms as manipulating intermediate representations
of probabilistic programs using higher-order functions and inductive
types, and their denotational semantics. <BR/><BR/> Semantic accounts of
continuous distributions use measurable spaces. However, this use of
higher-order functions presents a substantial technical difficulty: it
is impossible to define a measurable space structure over the collection
of measurable functions between arbitrary measurable spaces that is
compatible with standard operations on those functions, such as
application. I will explain how to overcome this difficulty using
quasi-Borel spaces, a recently proposed mathematical structure that
supports both function spaces and continuous distributions. <BR/><BR/>
More specifically, I will define a semantic class of structures for
representing probabilistic programs, and semantic validity criteria for
transformations of these representations in terms of distribution
preservation. I will review a collection of building blocks for
composing representations, and show how to use these building blocks to
validate common inference algorithms such as Sequential Monte Carlo and
Markov Chain Monte Carlo. To make the semantic manipulation closer to
its traditional measure theoretic origins, I will review and use Kock’s
synthetic measure theory. This notation was useful for proving a
quasi-Borel counterpart to the Metropolis-Hastings-Green theorem, which
I will also describe. <BR/><BR/> Joint with Adam Ścibior, Matthijs
Vákár, Sam Staton, Hongseok Yang, Yufei Cai, Klaus Ostermann, Zoubin
Ghahramani, Sean K. Moss, and Chris Heunen.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/fg-refs-lics-2017.pdf">A monad for full ground reference
cells</a>
</h4>
Talk given at the <a
href="http://lics.rwth-aachen.de/lics17/accepted.html">32st Annual
ACM/IEEE Symposium on Logic in Computer Science</a>, 23 June, 2017.</li>
</ul>
<blockquote>
<p>We present a denotational account of dynamic allocation of
potentially cyclic memory cells using a monad on a functor category. We
identify the collection of heaps as an object in a different functor
category equipped with a monad for adding hiding/encapsulation
capabilities to the heaps. We derive a monad for full ground references
supporting effect masking by applying a state monad transformer to the
encapsulation monad. To evaluate the monad, we present a denotational
semantics for a call-by-value calculus with full ground references, and
validate associated code transformations.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/lics2017-qbs.pdf">A convenient category for higher-order
probability theory</a>
</h4>
Talk given at the <a
href="http://lics.rwth-aachen.de/lics17/accepted.html">32st Annual
ACM/IEEE Symposium on Logic in Computer Science</a>, 20 June, 2017.</li>
</ul>
<blockquote>
<p>Higher-order probabilistic programming languages allow programmers to
write sophisticated models in machine learning and statistics in a
succinct and structured way, but step outside the standard
measure-theoretic formalization of probability theory. Programs may use
both higher-order functions and continuous distributions, or even define
a probability distribution on functions. But standard probability theory
cannot support higher-order functions, that is, the category of
measurable spaces is not cartesian closed. <BR/><BR/> Here we introduce
quasi-Borel spaces. We show that these spaces: form a new formalization
of probability theory replacing measurable spaces; form a cartesian
closed category and so support higher-order functions; form an
extensional category and so support good proof principles for equational
reasoning; and support continuous probability distributions. We
demonstrate the use of quasi-Borel spaces for higher-order functions and
probability by: showing that a well-known construction of probability
theory involving random functions gains a cleaner expression; and
generalizing de Finetti’s theorem, that is a crucial theorem in
probability theory, to quasi-Borel spaces.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a
href="talks/kammar-quasi-borel-spaces-oxford-quantum-workshop-2017.pdf">Quasi
Borel-spaces</a>
</h4>
Talk given at the University of Oxford Department of Computer Science
Quantum Group Workshop, 13 May, 2017.</li>
</ul>
<blockquote>
<P>
<p>I will explain what quasi-Borel spaces are, and outline how we’ve
been using them as a convenient alternative to measurable spaces in
probability theory and probabilistic programming that has well-behaved
higher-order, logical, and algebraic structure. <BR/><BR/> (Joint work
with Chris Heunen, Adam Scibior, Sam Staton, Matthijs Vakar, and
Hongseok Yang.)</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/kammar-levy-moss-staton-ref-cells-oxford.pdf">A monad for
full ground reference cells</a>
</h4>
Talk given at the <a
href="http://www.cs.ox.ac.uk/seminars/1778.html">Oxford Advanced Seminar
on Informatic Structures (OASIS)</a>, <a
href="http://www.cs.ox.ac.uk/research/fls/">Foundations Logic and
Structures theme</a>, <a href="http://www.ox.ac.uk">University of
Oxford</a> <a href="http://www.cs.ox.ac.uk">Department of Computer
Science</a>, 10 March, 2017.</li>
</ul>
<blockquote>
<P>
<p>I will describe how to build a monad on a functor category to model
dynamic allocation of potentially cyclic memory cells. In particular
I’ll explain how to tackle the challenge of ‘effect masking’ which means
roughly that ‘if you don’t need to know about memory access then you
can’t detect it.’, and use this monad to give a denotational account of
an ML-like language with reference cells, and validate associated
program transformations. <BR/><BR/> I will explain the main insight
behind our construction: identifying the collection of stores as an
object in a different functor category equipped with a monad for adding
hiding/encapsulation capabilities to the stores. I will then obtain the
full ground storage monad by applying a state monad transformer to the
encapsulation monad. <BR/><BR/> The talk is based on work with: Paul B.
Levy, Sean K. Moss, and Sam Staton
(http://arxiv.org/abs/1702.04908).</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/kammar-levy-moss-staton-ref-cells-cambridge.pdf">A monad
for full ground reference cells</a>
</h4>
Talk given at the <a
href="http://talks.cam.ac.uk/talk/index/70690">Logic and Semantics
Seminar</a>, <a
href="http://www.cl.cam.ac.uk/research/pls/">Programming, Logic, and
Semantics Group</a>, <a href="http://www.cam.ac.uk">University of
Cambridge</a> <a href="http://www.cl.cam.ac.uk">Computer Laboratory</a>,
17 February, 2017.</li>
</ul>
<blockquote>
<P>
<p>We present a denotational account of dynamic allocation of
potentially cyclic memory cells using a monad on a functor category. We
identify the collection of heaps as an object in a different functor
category equipped with a monad for adding hiding/encapsulation
capabilities to the heaps. We derive a monad for full ground references
supporting effect masking by applying a state monad transformer to the
encapsulation monad. To evaluate the monad, we present a denotational
semantics for a call-by-value calculus with full ground references, and
validate associated code transformations. <BR/><BR/> Joint work with:
Paul B. Levy, Sean K. Moss, and Sam Staton.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="">On the expressive power of user-defined effects: effect
handlers, monadic reflection, delimited control without
answer-type-modification</a>
</h4>
Talk given at the LSD Seminar, <a
href="http://www.cl.cam.ac.uk/research/pls/">Programming, Logic, and
Semantics Group</a>, <a href="http://www.cam.ac.uk">University of
Cambridge</a> <a href="http://www.cl.cam.ac.uk">Computer Laboratory</a>,
17 February, 2017.</li>
</ul>
<blockquote>
<P>
<p>We compare the expressive power of three programming abstractions for
user-defined computational effects: Bauer and Pretnar’s effect handlers,
Filinski’s monadic reflection, and delimited control. This comparison
allows a precise discussion about the relative merits of each
programming abstraction. <BR/><BR/> We present three calculi, one per
abstraction, extending Levy’s call-by-push-value. These comprise syntax,
operational semantics, a natural type-and-effect system, and, for
handlers and reflection, a set-theoretic denotational semantics. We
establish their basic meta-theoretic properties: adequacy, soundness,
and strong normalisation. Using Felleisen’s notion of a macro
translation, we show that these abstractions can macro-express each
other, and show which translations preserve typeability. We use the
adequate finitary set-theoretic denotational semantics for the monadic
calculus to show that effect handlers cannot be macro-expressed while
preserving typeability either by monadic reflection or by delimited
control. We supplement our development with a mechanised Abella
formalisation. <BR/><BR/> Joint work with Yannick Forster, Sam Lindley,
and Matija Pretnar.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<p><a href="">On the expressive power of user-defined effects: effect
handlers, monadic reflection, delimited control without
answer-type-modification</a></p>
</h4>
<p>Talk given at the <a
href="http://msp.cis.strath.ac.uk/">Mathematically Structured
Programming Group</a>, <a href="School%20of%20Informatics">University of
Strathclyde</a> <a
href="http://www.strath.ac.uk/science/computerinformationsciences/">Computer
and Information Sciences Department</a>, 06 February, 2017.</p>
<P/></li>
<li><h4>
<p><a href="talks/kammar-levy-moss-staton-ref-cells-lfcs.pdf">A monad
for full ground reference cells</a></p>
</h4>
<p>Talk given at the <a
href="http://wcms.inf.ed.ac.uk/lfcs/events/lfcs-seminar-ohad-kammar-a-monad-for-full-ground-reference-cells">LFCS
Seminar</a>, <a href="http://www.lfcs.inf.ed.ac.uk">Laboratory for
Foundations of Computer Science</a>, <a
href="http://www.ed.ac.uk">University of Edinburgh</a> <a
href="http://www.inf.ed.ac.uk">School of Informatics</a>, 31 January,
2017.</p></li>
</ul>
<blockquote>
<P>
We present a denotational account of dynamic allocation of potentially
cyclic memory cells using a monad on a functor category. We identify the
collection of heaps as an object in a different functor category
equipped with a monad for adding hiding/encapsulation capabilities to
the heaps. We derive a monad for full ground references supporting
effect masking by applying a state monad transformer to the
encapsulation monad. To evaluate the monad, we present a denotational
semantics for a call-by-value calculus with full ground references, and
validate associated code transformations.
<P>
<p><BR/><BR/> Joint work with: Paul B. Levy, Sean Moss, and Sam
Staton.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a
href="talks/forster-kammar-lindley-pretnar-expresiveness-srepls-2016.pdf">On
the Expressive Power of Algebraic Effects and Handlers</a>
</h4>
Talk given at the 4th South of England Regional Programming Language
Seminar (<a href="http://srepls4.doc.ic.ac.uk/">S-REPLS4</a>), <a
href="http://www.imperial.ac.uk/">Imperial College London</a>, 27
September, 2016.</li>
</ul>
<blockquote>
<p>Monads are the de-facto mechanism for adding user-defined
computational effects to programming languages. Support for monads has
been developed in general-purpose statically-typed functional
programming languages such as Haskell and OCaml, proof assistants such
as Coq, and other verification tools such as F-star. Algebraic effects
and handlers are a recently developed programming abstraction that
allows programmers to define and program with custom effects using a
specific delimited-control structure. This control structure has
straightforward type-system, computational intuition, operational and
denotational semantics, and reasoning principles. <BR/><BR/> Our goal is
to compare the expressive power of programming constructs facilitating
user-defined effects. We consider a calculus of effect handlers,
Filinski’s calculus of monadic reflection, which encapsulate
user-defined monads as a programmable abstraction, and a calculus of the
standard delimited control operators shift-zero and reset. We compare
the calculi using Felleisen’s notion of macro translations. When we
ignore the natural type systems associated with each calculus, each pair
of abstractions is macro inter-translateable, but this translation does
not preserve typability. We present preliminary results regarding the
non-existence of typability-preserving macro-translations, and
extensions to the type system that preserve typability. <BR/><BR/> Joint
work with Yannick Forster, Sam Lindley, and Matija Pretnar.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a
href="talks/kammar-moss-functional-models-of-ref-cells-hope-2016.pdf">Functional
models of full ground, and general, reference cells</a>
</h4>
Talk given at the <a
href="http://conf.researchr.org/track/icfp-2016/hope-2016-papers">HOPE’16</a>
Workshop, 18 September, 2016.</li>
</ul>
<blockquote>
<p>We present ongoing work developing a straightforward denotational
semantics for reference cells of arbitrary types based on sets-
with-structure and structure-preserving functions. We start with full
ground references — which can refer to ground values and (recursively)
ground references — where types denotes set-valued presheaves. By
considering stores as mixed-variance set-valued functors (i.e.,
profunctors), we obtain two monads for full ground state which can
interpret alloction, dereference, and mutation of full ground
references, while validating the usual equations. We use this structure
to give a denotational semantics to a monadic metalanguage with a
special construct for effect masking similar to Haskell’s runST. Time
permitting, we speculate how to extend this approach, using an
appropriate recursive domain equation, to account for ML-like general
reference cells.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<p><a href="talks/kammar-moss-pretnar-lola2016-value-restriction.pdf">No
value restriction is needed for algebraic effects and handlers</a></p>
</h4>
<p>Talk given at the Syntax and Semantics of Low-Level Languages (<a
href="http://lola.cse.buffalo.edu/">LOLA’16</a>), 10 July, 2016.</p>
<P/></li>
<li><h4>
<p><a
href="talks/kammar-pretnar-polymorphic-eff-seminaire-gallium.pdf">No
value restriction is needed for algebraic effects and handlers</a></p>
</h4>
<p>Talk given at the <a
href="http://gallium.inria.fr/seminaires/">Seminaire Gallium</a>, <a
href="https://www.inria.fr/centre/paris-rocquencourt">INRIA Paris
Rocquencourt</a>, France., 17 June, 2016.</p></li>
</ul>
<blockquote>
<p>We present a straightforward, sound Hindley-Milner polymorphic type
system for algebraic effects and handlers in a call-by-value calculus,
which allows type variable generalisation of arbitrary computations, not
just values. This result is surprising. On the one hand, the soundness
of unrestricted call-by-value Hindley-Milner polymorphism is known to
fail in the presence of computational effects such as reference cells
and continuations. On the other hand, many programming examples can be
recast to use effect handlers instead of these effects. Analysing the
expressive power of effect handlers with respect to state effects, we
claim handlers cannot express reference cells, and show they can
simulate dynamically scoped state. Time permitting, we will discuss the
denotational soundness theorem that led to this work. <BR/><BR/> Joint
work with Sean Moss and Matija Pretnar.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<p><a href="">No value restriction is needed for algebraic effects and
handlers</a></p>
</h4>
<p>Talk given at the <a
href="http://www.di.ens.fr/AntiqueTeam.html.en">ANTIQUE</a> seminar, <a
href="http://www.ens.fr/">École normale supérieure</a>, Paris, France.,
16 June, 2016.</p>
<P/></li>
<li><h4>
<p><a href="">No value restriction is needed for algebraic effects and
handlers</a></p>
</h4>
<p>Talk given at the 22nd International Conference on Types for Proofs
and Programs (<a href="http://www.types2016.uns.ac.rs/">TYPES 2016</a>),
26 May, 2016.</p></li>
</ul>
<P/>
<ul>
<li><h4>
<p><a href="">No value restriction is needed for algebraic effects and
handlers</a></p>
</h4>
<p>Talk given at the <a
href="https://bitbucket.org/logsem/public/wiki/Home">Logic and Semantics
group</a> seminar, <a href="http://cs.au.dk/">Department of Computer
Science</a>, <a href="http://au.dk">University of Aarhus</a>, Denmark.,
21 March, 2016.</p>
<P/></li>
<li><h4>
<p><a href="">No value restriction is needed for algebraic effects and
handlers</a></p>
</h4>
<p>Talk given at the Schloss Dagstuhl Seminar ‘From theory to practice
of algebraic effects and handlers’, 18 March, 2016.</p></li>
</ul>
<P/>
<ul>
<li><h4>
<a href="talks/kammar-moss-hope-a-den-sem-for-hm-poly.pdf">A
denotational semantics for Hindley-Milner Polymorphism</a>
</h4>
Talk given at the 4th ACM SIGPLAN Workshop on Higher-Order Programming
with Effects (<a
href="http://users-cs.au.dk/birke/hope-2015/">HOPE’15</a>), 30 August,
2015.</li>
</ul>
<blockquote>
<p>Hindley-Milner let-polymorphism in the presence of computational
effects, notably local state mixed with type recursion, requires
restriction to achieve type soundness. Existing solutions either
restrict generalisation over type variables, excluding opportunities for
sound polymorphism, or use types that expose the effectful nature of the
implementation. Our goal is to analyse the problem and existing
solutions denotationally, with the hope that such models will provide
new insights. <BR/><BR/> We present an intrinsically-typed
(Church-style) zeroth-order calculus of let-polymorphism. We define a
fibrational denotational semantics to the pure calculus, drawing on
ideas from models of the polymorphic lambda calculus, modifying Seeley’s
PL categories to use Ulmer’s relative adjunctions. We outline ongoing
and future work how to extend the pure semantics to include higher-order
functions and relative monads, and to incorporating local state and
recursive types into models by recursive domain equations. We conclude
by speculating how to use these postulated models to analyse the value
restriction and other solutions.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<p><a href="talks/mfps-syllabus-for-alg-eff.pdf">A syllabus for
algebraic effects (invited tutorial)</a></p>
</h4>
<p>Talk given at the Mathematical Foundations of Programming Semantics
XXXI (<a
href="http://events.cs.bham.ac.uk/mfps31/?lang=en">MFPS’15</a>), 25
June, 2015.</p>
<P/></li>
<li><h4>
<p><a href="drafts/kammar-locally-determined-colimits.pdf">A universal
characterisation of locally determined omega-colimits</a></p>
</h4>
<p>Talk given at the <a
href="http://www.pps.univ-paris-diderot.fr/~varacca/domains/Domains_XI/Home.html">Domains
XI</a> Workshop, 09 September, 2014.</p></li>
</ul>
<blockquote>
<p>Characterising colimiting omega-cocones of projection pairs in terms
of least upper bounds of their embeddings and projections is important
to the solution of recursive domain equations. We present a universal
characterisation of this local property as omega-cocontinuity of locally
continuous functors. We present a straightforward proof using the
enriched Yoneda embedding. The proof can be generalised to Cattani and
Fiore’s notion of locality for adjoint pairs.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/kammar-graphtool-hope.pdf">Graphical algebraic
foundations for monad stacks</a>
</h4>
Talk given at the 3rd <a href="http://www.acm.org">ACM</a> <a
href="http://www.sigplan.org/">SIGPLAN</a> Workshop on <a
href="https://www.mpi-sws.org/~neelk/hope2014/">Higher-Order Programming
with Effects (HOPE’14)</a>, 31 August, 2014.</li>
</ul>
<blockquote>
<p>Purely functional languages use sequences of monad transformers
called monad stacks to incorporate computational effects modularly. The
current practice is to intuitively find the appropriate stack for a
given task using intractable brute force and heuristics. We investigate
a systematic alternative. By restricting attention to algebraic stack
combinations, we provide a linear-time algorithm for generating all the
appropriate monad stacks, or decide no such stack exist. Our approach is
based on Hyland, Plotkin, and Power’s algebraic analysis of monad
transformers, who propose a graph-theoretical solution to this problem.
We extend their analysis with a straightforward connection to
series-parallel graphs, and demonstrate a web-tool for generating monad
stacks from a graph denoting the commutative interaction of effects.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="">Graphical algebraic foundations for monad stacks</a>
</h4>
Talk given at the <a href="http://www.ess.ecs.soton.ac.uk/">Electronic
and Software Systems</a> seminar, <a
href="http://www.southampton.ac.uk/">University of Southhampton</a>, 30
July, 2014.</li>
</ul>
<blockquote>
<p>Purely functional languages, e.g. Haskell, incorporate computational
effects modularly using sequences of monad transformers, termed monad
stacks. The current practice is to find the appropriate stack for a
given task intuitively. By restricting attention to algebraic stack
combinations, we provide a linear-time algorithm for generating all the
appropriate monad stacks, or decide no such stacks exist. Our approach
is based on Hyland, Plotkin, and Power’s algebraic analysis of monad
transformers, who propose a graph-theoretical solution to this problem.
We extend their analysis with a straightforward connection to the
modular decomposition of a graph and to cographs, a.k.a. series-parallel
graphs. We present an accessible and self-contained account of this
monad-stack generation problem, and, more generally, of the
decomposition of a combined algebraic theory into sums and tensors, and
its algorithmic solution. We provide a web-tool implementing this
algorithm intended for semantic investigations of effect combinations
and for monad stack generation.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="">Graphical algebraic foundations for monad stacks</a>
</h4>
Talk given at the <a href="http://www.ed.ac.uk">University of
Edinburgh</a> <a href="http://wcms.inf.ed.ac.uk/lfcs">LFCS</a> <a
href="http://wcms.inf.ed.ac.uk/lfcs/research/groups-and-projects/pl/programming-languages-interest-group">PLInG</a>,
02 June, 2014.</li>
</ul>
<blockquote>
<p>Haskell incorporates computational effects modularly using sequences
of monad transformers, termed monad stacks. The current practice is to
find the appropriate stack for a given task using intractable brute
force and heuristics. By restricting attention to algebraic stack
combinations, we provide a linear-time algorithm for generating all the
appropriate monad stacks, or decide no such stacks exist. Our approach
is based on Hyland, Plotkin, and Power’s algebraic analysis of monad
transformers, who propose a graph-theoretical solution to this problem.
We extend their analysis with a straightforward connection to the
modular decomposition of a graph and to cographs, a.k.a. series-parallel
graphs. We present an accessible and self-contained account of this
monad-stack generation problem, and, more generally, of the
decomposition of a combined algebraic theory into sums and tensors, and
its algorithmic solution. We provide a web-tool implementing this
algorithm intended for semantic investigations of effect combinations
and for monad stack generation.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="">Graphical algebraic foundations for monad stacks</a>
</h4>
Talk given at the <a href="http://www.strath.ac.uk">University of
Strathclyde</a> <a href="http://msp.cis.strath.ac.uk/">MSP</a> <a
href="http://msp.cis.strath.ac.uk/msp101.html">101 seminar series</a>,
28 May, 2014.</li>
</ul>
<blockquote>
<p>Haskell incorporates computational effects modularly using sequences
of monad transformers, termed monad stacks. The current practice is to
find the appropriate stack for a given task using intractable brute
force and heuristics. By restricting attention to algebraic stack
combinations, we provide a linear-time algorithm for generating all the
appropriate monad stacks, or decide no such stacks exist. Our approach
is based on Hyland, Plotkin, and Power’s algebraic analysis of monad
transformers, who propose a graph-theoretical solution to this problem.
We extend their analysis with a straightforward connection to the
modular decomposition of a graph and to cographs, a.k.a. series-parallel
graphs. We present an accessible and self-contained account of this
monad-stack generation problem, and, more generally, of the
decomposition of a combined algebraic theory into sums and tensors, and
its algorithmic solution. We provide a web-tool implementing this
algorithm intended for semantic investigations of effect combinations
and for monad stack generation.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="">An algebraic theory of type and effect systems</a>
</h4>
Talk given at the <a href="http://www.cam.ac.uk/">University of
Cambridge</a> <a href="http://www.cl.cam.ac.uk/">Computer Laboratory</a>
<a href="http://talks.cam.ac.uk/show/index/6375">Logic and Semantics
Seminar</a>, 13 December, 2013.</li>
</ul>
<blockquote>
<p>We present a theory of Gifford-style type-and-effect annotations,
where effect annotations are sets of effects, such as memory accesses or
exceptions. Our theory accounts for effect-dependent program
transformations for functional-imperative languages, as used in
optimizing compilers. Generality is achieved by recourse to the theory
of algebraic effects, a development of Moggi’s monadic theory of
computational effects that emphasizes the operations causing the effects
at hand. The key observation is that annotation effects denote algebraic
operations. After presenting our general type-and-effect system and its
semantics, we validate and generalize existing optimizations and add new
ones. Our theory also suggests a classification of these optimizations
into three classes, structural, local, and global: structural
optimizations always hold; local ones depend on the effect theory at
hand; and global ones depend on the global nature of that theory, such
as idempotency or absorption laws. We also give modularly-checkable
necessary and sufficient conditions for validating the optimizations.
Joint work with Gordon Plotkin.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="">An algebraic theory of type and effect systems</a>
</h4>
Talk given at the <a
href="http://projects.csail.mit.edu/pl/#seminar">MIT Programming
Languages Seminar</a>, 30 September, 2013.</li>
</ul>
<blockquote>
<p>We present a theory of Gifford-style type-and-effect annotations,
where effect annotations are sets of effects, such as memory accesses or
exceptions. Our theory accounts for effect-dependent program
transformations for functional-imperative languages, as used in
optimizing compilers. Generality is achieved by recourse to the theory
of algebraic effects, a development of Moggi’s monadic theory of
computational effects that emphasizes the operations causing the effects
at hand. The key observation is that annotation effects denote algebraic
operations. After presenting our general type-and-effect system and its
semantics, we validate and generalize existing optimizations and add new
ones. Our theory also suggests a classification of these optimizations
into three classes, structural, local, and global: structural
optimizations always hold; local ones depend on the effect theory at
hand; and global ones depend on the global nature of that theory, such
as idempotency or absorption laws. We also give modularly-checkable
necessary and sufficient conditions for validating the optimizations.
Joint work with Gordon Plotkin.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/ohad-jifp.pdf">A general theory of type-and-effect
systems via universal algebra</a>
</h4>
Talk given at the <a
href="http://www.liafa.univ-paris-diderot.fr/jifp/">Journées
d’Informatique Fondamentale de Paris Diderot</a>, 25 April, 2013.</li>
</ul>
<blockquote>
<p>We present a general theory of Gifford-style type-and-effect
annotations, where effect annotations are sets of effects, such as
memory accesses or exceptions. Our theory accounts for effect-dependent
program transformations for functional-imperative languages, as used in
optimising compilers. Using our theory, we validate and generalise many
existing optimisations and add new ones. Our general theory also
suggests a classification of these optimisations into three classes,
structural, local, and global. We also give modularly-checkable
necessary and sufficient conditions for validating the
optimisations.</p>
</blockquote>
<blockquote>
<p>Generality is achieved by recourse to the theory of algebraic
effects, a development of Moggi’s monadic theory of computational
effects that emphasises the operations causing the effects at hand. The
universal algebraic perspective gives an elementary and concrete view on
the monadic concepts. The key observation is that annotation effects can
be identified with the algebraic operation symbols. We describe how the
universal algebraic approach gives particularly simple characterisations
of the optimisations: structural optimisations always hold; local ones
depend on the effect theory at hand; and global ones depend on the
global nature of that theory, such as idempotency or absorption laws.
Time permitting, we outline how the theory generalises to more
sophisticated notions of universal algebra via enriched Lawvere theories
and factorisation systems.</p>
</blockquote>
<blockquote>
<p>Joint work with Gordon Plotkin.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a
href="talks/kammar-introduction-to-programming-language-semantics-2012.pdf">An
introduction to Programming Language Semantics</a>
</h4>
Talk given at the 1st join category theory and computer science seminar,
University of Cambridge, 18 November, 2012.</li>
</ul>
<blockquote>
<p>A brief introduction to programming language semantics. We will
covere key aspects of the operational and denotational approaches,
including type soundness, denotational soundness, adequacy. I will
present a logical relations proof, and show how category theory allows
to restructure it as a model in a suitable category of predicates.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/hope2012-talk.pdf">Handlers in Action</a>
</h4>
Talk given at the <a href="http://hope2012.mpi-sws.org/">1st ACM SIGPLAN
Workshop on Higher-Order Programming with Effects (HOPE’12)</a>, 09
September, 2012.</li>
</ul>
<blockquote>
<p>We present operational semantics for effect handlers. Introduced by
Plotkin and Pretnar, effect handlers form the basis of Bauer and
Pretnar’s Eff programming language. Our talk outlines three
contributions. * We propose the first small-step structural operational
semantics for a higher-order programming language with effect handlers,
and a sound type and effect system. * We exhibit two alternative effect
handler implementation techniques using free monads, and using
composable continuations.</p>
</blockquote>
<blockquote>
<ul>
<li>We show that Filinski’s monadic reflection is subsumed by effect
handlers.</li>
</ul>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/spls-2012-03-handlers-in-action.pdf">Handlers in
Action</a>
</h4>
Talk given at the <a
href="http://www.dcs.gla.ac.uk/research/spls/Mar12/">Scottish
Programming Lanugage Seminar (SPLS)</a>, 15 March, 2012.</li>
</ul>
<blockquote>
<p>We present a small-step operational semantics for a simplified
Call-by-Push-Value variant of Bauer and Pretnar’s Eff programming
language. Eff incorporates functional and imperative features by
adapting Plotkin and Pretnar’s effect handlers as a programming
paradigm.</p>
</blockquote>
<blockquote>
<p>This is preliminary work with Sam Lindley and Nicolas Oury.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a
href="talks/cmu-2012-01-30-algebraic-foundations-for-effect-dependent-optimisations.pdf">Algebraic
Foundations for Effect-Dependent Optimisations</a>
</h4>
Talk given at the <a
href="http://www.cs.cmu.edu/afs/.cs.cmu.edu/Web/Groups/pop/">Principles
of Programing Seminar (POP)</a>, 30 January, 2012.</li>
</ul>
<blockquote>
<p>We present a general theory of Gifford-style type and effect
annotations, where effect annotations are sets of effects. Generality is
achieved by recourse to the theory of algebraic effects, a development
of Moggi’s monadic theory of computational effects that emphasises the
operations causing the effects at hand and their equational theory. The
key observation is that annotation effects can be identified with
operation symbols.</p>
</blockquote>
<blockquote>
<p>We develop an annotated imperative and functional language with a
kind of computations for every effect set; it can be thought of as a
sequential, annotated intermediate language. We develop a range of
validated optimisations (i.e., equivalences), generalizing many existing
ones and adding new ones. We classify these optimisations as structural,
algebraic, or abstract: structural optimisations always hold; algebraic
ones depend on the effect theory at hand; and abstract ones depend on
the global nature of that theory (we give modularly-checkable sufficient
conditions for their validity). Joint work with Gordon Plotkin, to
appear in POPL’12.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a
href="talks/popl12-algebraic-foundations-for-effect-dependent-optimisations.pdf">Algebraic
Foundations for Effect-Dependent Optimisations</a>
</h4>
Talk given at the <a href="http://www.cse.psu.edu/popl/12/">39th
Symposium on Principles of Programming Languages (POPL’12)</a>, 26
January, 2012.</li>
</ul>
<blockquote>
<p>We present a general theory of Gifford-style type and effect
annotations, where effect annotations are sets of effects. Generality is
achieved by recourse to the theory of algebraic effects, a development
of Moggi’s monadic theory of computational effects that emphasises the
operations causing the effects at hand and their equational theory. The
key observation is that annotation effects can be identified with
operation symbols.</p>
</blockquote>
<blockquote>
<p>We develop an annotated version of Levy’s Call-by-Push-Value language
with a kind of computations for every effect set; it can be thought of
as a sequential, annotated intermediate language. We develop a range of
validated optimisations (i.e., equivalences), generalising many existing
ones and adding new ones. We classify these optimisations as structural,
algebraic, or abstract: structural optimisations always hold; algebraic
ones depend on the effect theory at hand; and abstract ones depend on
the global nature of that theory (we give modularly-checkable sufficient
conditions for their validity).</p>
</blockquote>
<blockquote>
<p>Joint work with Gordon Plotkin.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/ohad-nottingham-atoe-tea.pdf">Algebraic Foundations for
Effect-Dependent Optimisations</a>
</h4>
Talk given at the <a
href="http://fp.cs.nott.ac.uk/index.php?option=com_content&amp;view=article&amp;id=55&amp;Itemid=66">Functional
Programming Lab Seminar</a>, 11 January, 2012.</li>
</ul>
<blockquote>
<p>We present a general theory of Gifford-style type and effect
annotations, where effect annotations are sets of effects. Generality is
achieved by recourse to the theory of algebraic effects, a development
of Moggi’s monadic theory of computational effects that emphasises the
operations causing the effects at hand and their equational theory. The
key observation is that annotation effects can be identified with
operation symbols. We develop an annotated imperative and functional
language with a kind of computations for every effect set; it can be
thought of as a sequential, annotated intermediate language. We develop
a range of validated optimisations (i.e., equivalences), generalising
many existing ones and adding new ones. We classify these optimisations
as structural, algebraic, or abstract: structural optimisations always
hold; algebraic ones depend on the effect theory at hand; and abstract
ones depend on the global nature of that theory (we give
modularly-checkable sufficient conditions for their validity).</p>
</blockquote>
<blockquote>
<p>Joint work with Gordon Plotkin, to appear in POPL’12.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/semantics-rip-discussion-lab-lunch.pdf">Programming
Language Semantics: {Ret | Int | P}rospective Discussion</a>
</h4>
Talk given at the <a
href="http://wcms.inf.ed.ac.uk/lfcs/events/laboratory-luncheon">LFCS Lab
Lunch</a>, 20 September, 2011.</li>
</ul>
<blockquote>
<p>Defining the formal meaning of programming languages has been
investigated for nearly half a century. The foundational questions in
the field have impact on programming language theoreticians, designers
and implementors. In this quasi-historical session, we’ll review the
goals underlining semantics, and how operational and denotational
methods have been devised to investigate them. The review will be
followed by a short discussion about the current state of the theory,
tools and methodologies available. Was it a big waste of time?</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/ohad-ewce-atoe-tea.pdf">Algebraic Foundations for Type
and Effect Analysis</a>
</h4>
Talk given at the <a href="http://ewce.fmf.uni-lj.si/">European Workshop
on Computational Effects</a>, 18 March, 2011.</li>
</ul>
<blockquote>
<p>We propose a semantic foundation for optimisations based on type and
effect analysis. We present a multiple-effect CBPV-based calculus whose
denotational semantics is based on an effect-indexed structure of
adjunctions. When the underlying set of effects is specified by an
algebraic theory, we take effects to be given by sets of operations. The
required adjunction structure can then be obtained via a uniform process
of conservative restriction of the theory. The calculus and its
semantics is then extended by a straightforward generalisation of
Pretnar and Plotkin’s effect handlers to arbitrary, non-algebraic,
inter-effect handlers.</p>
</blockquote>
<blockquote>
<p>The modular composition of effects then boils down to ex- tension
conservativeness, and we show that some common ways to compose arbitrary
effects by sums and tensors are indeed conservative. In particular we
obtain conservative extension results for both the sum of a monad and a
free monad, and also for a unification of three common instances of the
tensor of theories that is obtained using monoid actions. This
unification includes the usual reader, state and writer monads and monad
transformers.</p>
</blockquote>
<blockquote>
<p>We use our calculus and its semantics to provide general effect-
dependent optimisations. We exemplify the machinery developed by
deriving a language with state, IO and exceptions, and their handlers.
Many of the already known effect-dependent optimisations are then
particular cases of our general ones. We have thus demonstrated the
possibility of a general theory of effect optimisations based on the
algebraic theory of effects.</p>
</blockquote>
<blockquote>
<p>Joint work with Gordon Plotkin.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/spls-2010-11-take-action-for-your-state.pdf">Take Action
for Your State!</a>
</h4>
Talk given at the joint <a
href="http://www.dcs.gla.ac.uk/research/spls/">Scottish Programming
Lanugage Seminar (SPLS)</a> and <a
href="http://sneezy.cs.nott.ac.uk/fun/">Fun in the Afternoon</a>, 24
November, 2010.</li>
</ul>
<blockquote>
<p>There is a conceptual connection between the State, Reader and Writer
monads. However, the State and Reader monads only require a type,
whereas the Writer monad requires a monoid. I will introduce and use
Plotkin’s and Power’s algebraic theory of effects to formalise this
connection using the notions of monoid actions and conservative
restriction. This work results in a generalised notion of the State and
Reader monads and monad transformers for an arbitrary monoid action.
This is joint work with Gordon Plotkin.</p>
</blockquote>
<P/>
<ul>
<li><h4>
<a href="talks/2010-01-19-lablunch-well-kept-secret.pdf">A well kept
secret…</a>
</h4>
Talk given at the <a
href="http://wcms.inf.ed.ac.uk/lfcs/events/laboratory-luncheon">LFCS Lab
Lunch</a>, 19 January, 2010.</li>
</ul>
<blockquote>
<p>At the end of last year, a prominent Category Theorist revealed a
well kept secret on the categories mailing list. I will present a brief
overview of the various threads that erupted from this revelation, and
how they are relevant to Your Research (TM).</p>
</blockquote>
<P/>
<h3>
<a name="reports"></a>Reports
</h3>
<ul>
<li><h4>
<p><a href="reports/probprog18-poster-qbs.pdf">Foundations for
Probabilistic Programming</a></p>
</h4>
<p>Internal Report: Poster presented at the 1st <a
href="http://probprog.cc/">Probabilistic Programming Conference</a>, 19
June, 2018.</p>
<P/></li>
<li><h4>
<p><a href="https://arxiv.org/abs/1707.06685">A monadic solution to the
Cartwright-Felleisen-Wadler conjecture</a></p>
</h4>
<p>Internal Report: talk proposal accepted to, and delivered by <a
href="http://www.cl.cam.ac.uk/~dm606/">Dylan McDermott</a> the <a
href="http://icfp17.sigplan.org/track/hope-2017-papers">Workshop on
Higher-Order Programming with Effects (HOPE’17)</a>, 03 September,
2017.</p></li>
</ul>
<P/>
<ul>
<li><h4>
<p><a href="reports/ohad-research-proposal.pdf">Algebraic Approaches to
Semantics</a></p>
</h4>
<p>Internal Report: Research Proposal, 24 February, 2010.</p>
<P/></li>
</ul>          <footer>
            <div class="footer-discover">
              <div class="container">
                <h3>The University of Edinburgh</h3> </div>
            </div>
            <div class="footer">
              <div class="container">
                <div class="row">
                  <div class="col-sm-8">
                    <p> The University of Edinburgh is a charitable body, registered in Scotland, with registration number SC005336, VAT Registration Number GB&nbsp;592&nbsp;9507&nbsp;00, and is acknowledged by the UK authorities as a “<a href="https://www.gov.uk/guidance/recognised-uk-degrees">Recognised body</a>” which has been granted degree awarding powers. </p>
                  </div>
                  <div class="col-sm-4 col-xs-6" align="right">
                    <a href="https://www.ed.ac.uk/about/mission-governance/affiliations"> <img class="pull-right img-responsive" alt="University affiliations" src="footer-affiliations.png"> </a>
                    <p/>
                    <a class="btn btn-uoe btn-sm" href="https://www.myed.ed.ac.uk/"> MyEd login <span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> </div>
                </div>
              </div>
            </div>
            <div class="container container-footer-copyright">
              <div class="copyright">
                <p>Unless explicitly stated otherwise, all material is copyright © Ohad Kammar 2018.</p>
              </div>
            </div>
            <div class="container text-right">
              <a rel="nofollow" class="footer-login-link" href="https://www.edweb.ed.ac.uk/user/login?destination=node/4"> <abbr class="initialism">CMS</abbr> login <span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
            </div>
          </footer>




          <!-- required jQuery -->
          <script src="js/jquery.min.js"></script>
          <!-- EdGEL JS - includes all Bootstrap plugins -->
          <script src="js/edgel.min.js"></script>
  </body>
</html>
